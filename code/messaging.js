"use strict";

/**
 * Messaging, 18.3.2016 Spaceify Oy
 * 
 * @class Messaging
 */

var Logger = require("./logger");
var SpaceifyConfig = require("./spaceifyconfig");
var SpaceifyUtility = require("./spaceifyutility");
var WebSocketServer = require("./websocketserver");

function Messaging()
{
var self = this;

var logger = new Logger();
var config = new SpaceifyConfig();
var utility = new SpaceifyUtility();
var webSocketServer = null;

var messageIds = {};
var connections = {};

var key = config.SPACEIFY_TLS_PATH + config.SERVER_KEY;
var crt = config.SPACEIFY_TLS_PATH + config.SERVER_CRT;
var caCrt = config.SPACEIFY_WWW_PATH + config.SPACEIFY_CRT;

var messageListener = null;

	// CONSTANTS -- -- -- -- -- -- -- -- -- -- //
var GARBAGE_INTERVAL = 60000;

self.MESSAGE = 1;
self.MESSAGE_END = 2;
self.MESSAGE_ERROR = 3;
self.MESSAGE_WARNING = 4;
self.MESSAGE_NOTIFY = 5;
self.MESSAGE_ANSWER = 6;
self.MESSAGE_QUESTION = 7;
self.MESSAGE_CONFIRM = 8;
self.MESSAGE_FAILED = 9;
self.MESSAGE_TIMED_OUT = 10;

self.listen = function(port, callback)
	{
	try {
		webSocketServer = new WebSocketServer();

		webSocketServer.setEventListener(self);
		webSocketServer.setServerDownListener(serverDownListener);

		webSocketServer.listen({hostname: config.ALL_IPV4_LOCAL, port: port, isSecure: true, key: key, crt: crt, caCrt: caCrt, keepUp: true, debug: true}, callback);
		}
	catch(err)
		{
		logger.error(err, true, true, logger.ERROR);
		}
	}

self.close = function()
	{
	webSocketServer.close();

	messageIds = {};
	}

//** EventListener interface implementation (addConnection, onMessage and onDisconnected events originate from server and connections)
self.addConnection = function(conn)
	{
	try	{
		if(!conn.getId())
			conn.setId(utility.generateRandomConnectionId(connections));

		connections[conn.getId()] = conn;
		conn.setEventListener(self);

		connections[conn.getId()].connectionTimeStamp = Date.now();

		return conn.getId();
		}
	catch(err)
		{
		logger.error(err, true, true, logger.ERROR);
		}
	};

self.onDisconnected = function(id)
	{
	var ids;
	
	try	{
		ids = Object.keys(messageIds);

		for(var i = 0; i < ids.length; i++)
			{
			if(messageIds[ids[i]].connectionId == id)
				delete messageIds[ids[i]];
			}
		}
	catch(err)
		{
		logger.error(err, true, true, logger.ERROR);
		}
	}

self.onMessage = function(message, connection)
	{
	try {
		message = utility.parseJSON(message, true);

		if(!message.type || !message.messageId)
			throw "";

		// Connections that have messageId generated by this class can start listening the messages
		if(message.type == self.MESSAGE_CONFIRM)
			{
			if(message.messageId in messageIds)								// Accept the confirmation when messageId can be paired with a connection
				messageIds[message.messageId].connectionId = connection.getId();
			else															// Close the connection otherwise
				{
				connections[connection.getId()].close();
				delete connections[connection.getId()];
				}
			}
		// Client handles other types of messages
		else if(messageListener && message.messageId in messageIds && messageIds[message.messageId].connectionId)
			messageListener(message);
		}
	catch(err)
		{}
	}

	// -- -- -- -- -- -- -- -- -- -- //
var serverDownListener = function()
	{
	messageIds = {};
	}

self.setMessageListener = function(listener)
	{
	messageListener = (typeof listener == "function" ? listener : null);
	}

self.sendMessage = function(messages)
	{
	var message = "";

	for(var id in messageIds)																// Send messages to the verified connections
		{
		if(!messageIds[id].connectionId)
			continue;

		for(var i = 0; i < messages.length; i++)
			{
			if(typeof messages[i] == "string")
				message = {type: self.MESSAGE, message: messages[i]};
			else
				message = messages[i];

			connections[messageIds[id].connectionId].send(JSON.stringify(message));
			}
		}
	}

self.messageIdRequested = function()
	{
	var messageId = utility.randomString(64, true);

	messageIds[messageId] = { connectionTimeStamp: Date.now(), connectionId: null };

	return messageId;
	}

var carbageCollection = function()
	{
	var i;
	var ts;
	var ids;

	// Allow one minute to confirm a messageId
	ids = Object.keys(messageIds);
	for(i = 0; i < ids.length; i++)
		{
		ts = Date.now() - messageIds[ids[i]].connectionTimeStamp;
		if(ts >= GARBAGE_INTERVAL)
			delete messageIds[ids[i]];
		}

	// Allow connections unconfirmed with a messageId to be open for one minute before disconnecting
	ids = Object.keys(connections);
	for(i = 0; i < ids.length; i++)
		{
		ts = Date.now() - connectionIds[ids[i]].connectionTimeStamp;
		if(ts >= GARBAGE_INTERVAL)
			{
			connections[ids[i]].close();
			delete connections[ids[i]];
			}
		}
	}

}

module.exports = Messaging;