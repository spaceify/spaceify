/*
 * Generated automatically from cf.data by ./cf_gen
 *
 * Abstract: This file contains routines used to configure the
 *           variables in the squid server.
 */

static void
default_line(const char *s)
{
    LOCAL_ARRAY(char, tmp_line, BUFSIZ);
    xstrncpy(tmp_line, s, BUFSIZ);
    xstrncpy(config_input_line, s, BUFSIZ);
    config_lineno++;
    parse_line(tmp_line);
}

static void
default_all(void)
{
    cfg_filename = "Default Configuration";
    config_lineno = 0;
    // No default for auth_param
    default_line("authenticate_cache_garbage_interval 1 hour");
    default_line("authenticate_ttl 1 hour");
    default_line("authenticate_ip_ttl 0 seconds");
    // No default for external_acl_type
    default_line("acl ssl::certHasExpired ssl_error X509_V_ERR_CERT_HAS_EXPIRED");
    default_line("acl ssl::certNotYetValid ssl_error X509_V_ERR_CERT_NOT_YET_VALID");
    default_line("acl ssl::certDomainMismatch ssl_error SQUID_X509_V_ERR_DOMAIN_MISMATCH");
    default_line("acl ssl::certUntrusted ssl_error X509_V_ERR_INVALID_CA X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN X509_V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY X509_V_ERR_CERT_UNTRUSTED");
    default_line("acl ssl::certSelfSigned ssl_error X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT");
    default_line("acl all src all");
    default_line("acl manager url_regex -i ^cache_object:// +i ^https?://[^/]+/squid-internal-mgr/");
    default_line("acl localhost src 127.0.0.1/32 ::1");
    default_line("acl to_localhost dst 127.0.0.0/8 0.0.0.0/32 ::1");
    // No default for follow_x_forwarded_for
#if FOLLOW_X_FORWARDED_FOR
    default_line("acl_uses_indirect_client on");
#endif
#if FOLLOW_X_FORWARDED_FOR&&USE_DELAY_POOLS
    default_line("delay_pool_uses_indirect_client on");
#endif
#if FOLLOW_X_FORWARDED_FOR
    default_line("log_uses_indirect_client on");
#endif
#if FOLLOW_X_FORWARDED_FOR&&LINUX_NETFILTER
    default_line("tproxy_uses_indirect_client off");
#endif
    // No default for http_access
    // No default for adapted_http_access
    // No default for http_reply_access
    // No default for icp_access
    // No default for htcp_access
    // No default for htcp_clr_access
    // No default for miss_access
    // No default for ident_lookup_access
    // No default for reply_body_max_size
    // No default for http_port
    // No default for https_port
    // No default for tcp_outgoing_tos
    // No default for clientside_tos
    // No default for tcp_outgoing_mark
    // No default for clientside_mark
    // No default for qos_flows
    // No default for tcp_outgoing_address
    default_line("host_verify_strict off");
    default_line("client_dst_passthru on");
#if USE_SSL
    default_line("ssl_unclean_shutdown off");
#endif
    // No default for ssl_engine
    // No default for sslproxy_client_certificate
    // No default for sslproxy_client_key
#if USE_SSL
    default_line("sslproxy_version 1");
#endif
    // No default for sslproxy_options
    // No default for sslproxy_cipher
    // No default for sslproxy_cafile
    // No default for sslproxy_capath
    // No default for ssl_bump
    // No default for sslproxy_flags
    // No default for sslproxy_cert_error
    // No default for sslproxy_cert_sign
    // No default for sslproxy_cert_adapt
    // No default for sslpassword_program
#if USE_SSL_CRTD
    default_line("sslcrtd_program /usr/lib/squid3/ssl_crtd -s /var/lib/ssl_db -M 4MB");
#endif
#if USE_SSL_CRTD
    default_line("sslcrtd_children 32 startup=5 idle=1");
#endif
    // No default for cache_peer
    // No default for cache_peer_domain
    // No default for cache_peer_access
    // No default for neighbor_type_domain
    default_line("dead_peer_timeout 10 seconds");
    default_line("forward_max_tries 10");
    // No default for hierarchy_stoplist
    default_line("cache_mem 256 MB");
    default_line("maximum_object_size_in_memory 512 KB");
    // No default for memory_cache_shared
    default_line("memory_cache_mode always");
    default_line("memory_replacement_policy lru");
    default_line("cache_replacement_policy lru");
    // No default for cache_dir
    default_line("store_dir_select_algorithm least-load");
    default_line("max_open_disk_fds 0");
    default_line("minimum_object_size 0 KB");
    default_line("maximum_object_size 4 MB");
    default_line("cache_swap_low 90");
    default_line("cache_swap_high 95");
    // No default for logformat
    // No default for access_log
    // No default for icap_log
    default_line("logfile_daemon /usr/lib/squid3/log_file_daemon");
    // No default for log_access
    // No default for log_icap
    // No default for cache_store_log
    // No default for cache_swap_state
    default_line("logfile_rotate 0");
    default_line("mime_table /usr/share/squid3/mime.conf");
    default_line("log_mime_hdrs off");
    default_line("pid_filename /var/run/squid3.pid");
    default_line("client_netmask no_addr");
    default_line("strip_query_terms on");
    default_line("buffered_logs off");
#if USE_ICMP
    default_line("netdb_filename stdio:/var/log/squid3/netdb.state");
#endif
    // No default for cache_log
    default_line("debug_options ALL,1");
    // No default for coredump_dir
    default_line("ftp_user Squid@");
    default_line("ftp_passive on");
    default_line("ftp_epsv_all off");
    default_line("ftp_epsv on");
    default_line("ftp_eprt on");
    default_line("ftp_sanitycheck on");
    default_line("ftp_telnet_protocol on");
    default_line("diskd_program /usr/lib/squid3/diskd");
#if USE_UNLINKD
    default_line("unlinkd_program /usr/lib/squid3/unlinkd");
#endif
#if USE_ICMP
    default_line("pinger_program /usr/lib/squid3/pinger");
#endif
#if USE_ICMP
    default_line("pinger_enable on");
#endif
    // No default for url_rewrite_program
    default_line("url_rewrite_children 20 startup=0 idle=1 concurrency=0");
    default_line("url_rewrite_host_header on");
    // No default for url_rewrite_access
    default_line("url_rewrite_bypass off");
    // No default for cache
    default_line("max_stale 1 week");
    // No default for refresh_pattern
    default_line("quick_abort_min 16 KB");
    default_line("quick_abort_max 16 KB");
    default_line("quick_abort_pct 95");
    default_line("read_ahead_gap 16 KB");
#if USE_HTTP_VIOLATIONS
    default_line("negative_ttl 0 seconds");
#endif
    default_line("positive_dns_ttl 6 hours");
    default_line("negative_dns_ttl 1 minutes");
    // No default for range_offset_limit
    default_line("minimum_expiry_time 60 seconds");
    default_line("store_avg_object_size 13 KB");
    default_line("store_objects_per_bucket 20");
    default_line("request_header_max_size 64 KB");
    default_line("reply_header_max_size 64 KB");
    default_line("request_body_max_size 0 KB");
    default_line("client_request_buffer_max_size 512 KB");
    default_line("chunked_request_body_max_size 64 KB");
    // No default for broken_posts
#if FOLLOW_X_FORWARDED_FOR&&USE_ADAPTATION
    default_line("adaptation_uses_indirect_client on");
#endif
#if USE_HTTP_VIOLATIONS
    default_line("via on");
#endif
    default_line("ie_refresh off");
    default_line("vary_ignore_expire off");
    default_line("request_entities off");
    // No default for request_header_access
    // No default for reply_header_access
    // No default for request_header_replace
    // No default for reply_header_replace
    // No default for request_header_add
    default_line("relaxed_header_parser on");
    default_line("forward_timeout 4 minutes");
    default_line("connect_timeout 1 minute");
    default_line("peer_connect_timeout 30 seconds");
    default_line("read_timeout 15 minutes");
    default_line("write_timeout 15 minutes");
    default_line("request_timeout 5 minutes");
    default_line("client_idle_pconn_timeout 2 minutes");
    default_line("client_lifetime 1 day");
    default_line("half_closed_clients off");
    default_line("server_idle_pconn_timeout 1 minute");
#if USE_IDENT
    default_line("ident_timeout 10 seconds");
#endif
    default_line("shutdown_lifetime 30 seconds");
    default_line("cache_mgr webmaster");
    // No default for mail_from
    default_line("mail_program mail");
    default_line("cache_effective_user proxy");
    // No default for cache_effective_group
    default_line("httpd_suppress_version_string off");
    // No default for visible_hostname
    // No default for unique_hostname
    // No default for hostname_aliases
    default_line("umask 027");
    default_line("announce_period 0");
    default_line("announce_host tracker.ircache.net");
    // No default for announce_file
    default_line("announce_port 3131");
    // No default for httpd_accel_surrogate_id
    default_line("http_accel_surrogate_remote off");
#if USE_SQUID_ESI
    default_line("esi_parser custom");
#endif
#if USE_DELAY_POOLS
    default_line("delay_pools 0");
#endif
    // No default for delay_class
    // No default for delay_access
    // No default for delay_parameters
#if USE_DELAY_POOLS
    default_line("delay_initial_bucket_level 50");
#endif
#if USE_DELAY_POOLS
    default_line("client_delay_pools 0");
#endif
#if USE_DELAY_POOLS
    default_line("client_delay_initial_bucket_level 50");
#endif
    // No default for client_delay_parameters
    // No default for client_delay_access
#if USE_WCCP
    default_line("wccp_router any_addr");
#endif
    // No default for wccp2_router
#if USE_WCCP
    default_line("wccp_version 4");
#endif
#if USE_WCCPv2
    default_line("wccp2_rebuild_wait on");
#endif
#if USE_WCCPv2
    default_line("wccp2_forwarding_method gre");
#endif
#if USE_WCCPv2
    default_line("wccp2_return_method gre");
#endif
#if USE_WCCPv2
    default_line("wccp2_assignment_method hash");
#endif
    // No default for wccp2_service
    // No default for wccp2_service_info
#if USE_WCCPv2
    default_line("wccp2_weight 10000");
#endif
#if USE_WCCP
    default_line("wccp_address 0.0.0.0");
#endif
#if USE_WCCPv2
    default_line("wccp2_address 0.0.0.0");
#endif
    default_line("client_persistent_connections on");
    default_line("server_persistent_connections on");
    default_line("persistent_connection_after_error on");
    default_line("detect_broken_pconn off");
#if USE_CACHE_DIGESTS
    default_line("digest_generation on");
#endif
#if USE_CACHE_DIGESTS
    default_line("digest_bits_per_entry 5");
#endif
#if USE_CACHE_DIGESTS
    default_line("digest_rebuild_period 1 hour");
#endif
#if USE_CACHE_DIGESTS
    default_line("digest_rewrite_period 1 hour");
#endif
#if USE_CACHE_DIGESTS
    default_line("digest_swapout_chunk_size 4096 bytes");
#endif
#if USE_CACHE_DIGESTS
    default_line("digest_rebuild_chunk_percentage 10");
#endif
#if SQUID_SNMP
    default_line("snmp_port 0");
#endif
    // No default for snmp_access
#if SQUID_SNMP
    default_line("snmp_incoming_address any_addr");
#endif
#if SQUID_SNMP
    default_line("snmp_outgoing_address no_addr");
#endif
    default_line("icp_port 0");
#if USE_HTCP
    default_line("htcp_port 0");
#endif
    default_line("log_icp_queries on");
    default_line("udp_incoming_address any_addr");
    default_line("udp_outgoing_address no_addr");
    default_line("icp_hit_stale off");
    default_line("minimum_direct_hops 4");
    default_line("minimum_direct_rtt 400");
    default_line("netdb_low 900");
    default_line("netdb_high 1000");
    default_line("netdb_ping_period 5 minutes");
    default_line("query_icmp off");
    default_line("test_reachability off");
    default_line("icp_query_timeout 0");
    default_line("maximum_icp_query_timeout 2000");
    default_line("minimum_icp_query_timeout 5");
    default_line("background_ping_rate 10 seconds");
    // No default for mcast_groups
#if MULTICAST_MISS_STREAM
    default_line("mcast_miss_addr no_addr");
#endif
#if MULTICAST_MISS_STREAM
    default_line("mcast_miss_ttl 16");
#endif
#if MULTICAST_MISS_STREAM
    default_line("mcast_miss_port 3135");
#endif
#if MULTICAST_MISS_STREAM
    default_line("mcast_miss_encode_key XXXXXXXXXXXXXXXX");
#endif
    default_line("mcast_icp_query_timeout 2000");
    default_line("icon_directory /usr/share/squid3/icons");
    default_line("global_internal_static on");
    default_line("short_icon_urls on");
    // No default for error_directory
    // No default for error_default_language
#if USE_ERR_LOCALES
    default_line("error_log_languages on");
#endif
    default_line("err_page_stylesheet /etc/squid3/errorpage.css");
    // No default for err_html_text
    default_line("email_err_data on");
    // No default for deny_info
    default_line("nonhierarchical_direct on");
    default_line("prefer_direct off");
    // No default for always_direct
    // No default for never_direct
    default_line("incoming_udp_average 6");
    default_line("incoming_tcp_average 4");
    default_line("incoming_dns_average 4");
    default_line("min_udp_poll_cnt 8");
    default_line("min_dns_poll_cnt 8");
    default_line("min_tcp_poll_cnt 8");
    // No default for accept_filter
    default_line("client_ip_max_connections -1");
    default_line("tcp_recv_bufsize 0 bytes");
#if ICAP_CLIENT
    default_line("icap_enable off");
#endif
    // No default for icap_connect_timeout
    // No default for icap_io_timeout
#if ICAP_CLIENT
    default_line("icap_service_failure_limit 10");
#endif
#if ICAP_CLIENT
    default_line("icap_service_revival_delay 180");
#endif
#if ICAP_CLIENT
    default_line("icap_preview_enable on");
#endif
#if ICAP_CLIENT
    default_line("icap_preview_size -1");
#endif
#if ICAP_CLIENT
    default_line("icap_206_enable on");
#endif
#if ICAP_CLIENT
    default_line("icap_default_options_ttl 60");
#endif
#if ICAP_CLIENT
    default_line("icap_persistent_connections on");
#endif
#if USE_ADAPTATION
    default_line("adaptation_send_client_ip off");
#endif
#if USE_ADAPTATION
    default_line("adaptation_send_username off");
#endif
#if ICAP_CLIENT
    default_line("icap_client_username_header X-Client-Username");
#endif
#if ICAP_CLIENT
    default_line("icap_client_username_encode off");
#endif
    // No default for icap_service
    // No default for icap_class
    // No default for icap_access
#if USE_ECAP
    default_line("ecap_enable off");
#endif
    // No default for ecap_service
    // No default for loadable_modules
    // No default for adaptation_service_set
    // No default for adaptation_service_chain
    // No default for adaptation_access
#if USE_ADAPTATION
    default_line("adaptation_service_iteration_limit 16");
#endif
    // No default for adaptation_masterx_shared_names
    // No default for adaptation_meta
    // No default for icap_retry
#if ICAP_CLIENT
    default_line("icap_retry_limit 0");
#endif
    default_line("check_hostnames off");
    default_line("allow_underscore on");
#if USE_DNSHELPER
    default_line("cache_dns_program /usr/lib/squid3/dnsserver");
#endif
#if USE_DNSHELPER
    default_line("dns_children 32 startup=1 idle=1");
#endif
#if !USE_DNSHELPER
    default_line("dns_retransmit_interval 5 seconds");
#endif
#if !USE_DNSHELPER
    default_line("dns_timeout 30 seconds");
#endif
    // No default for dns_packet_max
    default_line("dns_defnames off");
    // No default for dns_nameservers
    default_line("hosts_file /etc/hosts");
    // No default for append_domain
#if !USE_DNSHELPER
    default_line("ignore_unknown_nameservers on");
#endif
#if !USE_DNSHELPER
    default_line("dns_v4_first off");
#endif
    default_line("ipcache_size 1024");
    default_line("ipcache_low 90");
    default_line("ipcache_high 95");
    default_line("fqdncache_size 1024");
    default_line("memory_pools on");
    default_line("memory_pools_limit 5 MB");
    default_line("forwarded_for on");
    // No default for cachemgr_passwd
    default_line("client_db on");
    default_line("refresh_all_ims off");
#if USE_HTTP_VIOLATIONS
    default_line("reload_into_ims off");
#endif
    default_line("connect_retries 0");
    default_line("retry_on_error off");
    default_line("as_whois_server whois.ra.net");
    default_line("offline_mode off");
    default_line("uri_whitespace strip");
    // No default for chroot
    default_line("balance_on_multiple_ip off");
    default_line("pipeline_prefetch off");
    default_line("high_response_time_warning 0");
    default_line("high_page_fault_warning 0");
    default_line("high_memory_warning 0 KB");
    default_line("sleep_after_fork 0");
#if _SQUID_MSWIN_
    default_line("windows_ipaddrchangemonitor on");
#endif
#if USE_SQUID_EUI
    default_line("eui_lookup on");
#endif
    default_line("max_filedescriptors 0");
    default_line("workers 1");
    // No default for cpu_affinity_map
    cfg_filename = NULL;
}

static void
defaults_if_none(void)
{
    cfg_filename = "Default Configuration (if absent)";
    config_lineno = 0;
#if FOLLOW_X_FORWARDED_FOR
    if (check_null_acl_access(Config.accessList.followXFF)) {
        default_line("follow_x_forwarded_for deny all");
    }
#endif
    if (check_null_acl_access(Config.accessList.http)) {
        default_line("http_access deny all");
    }
    if (check_null_access_log(Config.Log.accesslogs)) {
        default_line("access_log daemon:/var/log/squid3/access.log squid");
    }
    if (check_null_string(Debug::cache_log)) {
        default_line("cache_log /var/log/squid3/cache.log");
    }
    if (check_null_string(Config.coredump_dir)) {
        default_line("coredump_dir none");
    }
#if USE_WCCPv2
    if (check_null_wccp2_service(Config.Wccp2.info)) {
        default_line("wccp2_service standard 0");
    }
#endif
#if ICAP_CLIENT
    if (check_null_acl_access(Adaptation::Icap::TheConfig.repeat)) {
        default_line("icap_retry deny all");
    }
#endif
    cfg_filename = NULL;
}

static void
defaults_postscriptum(void)
{
    cfg_filename = "Default Configuration (postscriptum)";
    config_lineno = 0;
#if USE_SSL
    default_line("sslproxy_cert_sign signUntrusted ssl::certUntrusted");
    default_line("sslproxy_cert_sign signSelf ssl::certSelfSigned");
    default_line("sslproxy_cert_sign signTrusted all");
#endif
    cfg_filename = NULL;
}

static int
parse_line(char *buff)
{
	char	*token;
	if ((token = strtok(buff, w_space)) == NULL) 
		return 1;	/* ignore empty lines */
    if (!strcmp(token, "broken_vary_encoding")) {
        debugs(0, DBG_CRITICAL, "ERROR: Directive 'broken_vary_encoding' is obsolete.");
        debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "broken_vary_encoding : This option is not yet supported by Squid-3.");
        parse_obsolete(token);
        return 1;
    };
    if (!strcmp(token, "cache_vary")) {
        debugs(0, DBG_CRITICAL, "ERROR: Directive 'cache_vary' is obsolete.");
        debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "cache_vary : This option is not yet supported by Squid-3.");
        parse_obsolete(token);
        return 1;
    };
    if (!strcmp(token, "collapsed_forwarding")) {
        debugs(0, DBG_CRITICAL, "ERROR: Directive 'collapsed_forwarding' is obsolete.");
        debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "collapsed_forwarding : This option is not yet supported by Squid-3. see http://bugs.squid-cache.org/show_bug.cgi?id=3495");
        parse_obsolete(token);
        return 1;
    };
    if (!strcmp(token, "error_map")) {
        debugs(0, DBG_CRITICAL, "ERROR: Directive 'error_map' is obsolete.");
        debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "error_map : This option is not yet supported by Squid-3.");
        parse_obsolete(token);
        return 1;
    };
    if (!strcmp(token, "external_refresh_check")) {
        debugs(0, DBG_CRITICAL, "ERROR: Directive 'external_refresh_check' is obsolete.");
        debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "external_refresh_check : This option is not yet supported by Squid-3.");
        parse_obsolete(token);
        return 1;
    };
    if (!strcmp(token, "ignore_ims_on_miss")) {
        debugs(0, DBG_CRITICAL, "ERROR: Directive 'ignore_ims_on_miss' is obsolete.");
        debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ignore_ims_on_miss : This option is not yet supported by Squid-3.");
        parse_obsolete(token);
        return 1;
    };
    if (!strcmp(token, "location_rewrite_program")) {
        debugs(0, DBG_CRITICAL, "ERROR: Directive 'location_rewrite_program' is obsolete.");
        debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "location_rewrite_program : This option is not yet supported by Squid-3.");
        parse_obsolete(token);
        return 1;
    };
    if (!strcmp(token, "location_rewrite_concurrency")) {
        debugs(0, DBG_CRITICAL, "ERROR: Directive 'location_rewrite_concurrency' is obsolete.");
        debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "location_rewrite_concurrency : This option is not yet supported by Squid-3.");
        parse_obsolete(token);
        return 1;
    };
    if (!strcmp(token, "location_rewrite_children")) {
        debugs(0, DBG_CRITICAL, "ERROR: Directive 'location_rewrite_children' is obsolete.");
        debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "location_rewrite_children : This option is not yet supported by Squid-3.");
        parse_obsolete(token);
        return 1;
    };
    if (!strcmp(token, "location_rewrite_access")) {
        debugs(0, DBG_CRITICAL, "ERROR: Directive 'location_rewrite_access' is obsolete.");
        debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "location_rewrite_access : This option is not yet supported by Squid-3.");
        parse_obsolete(token);
        return 1;
    };
    if (!strcmp(token, "refresh_stale_hit")) {
        debugs(0, DBG_CRITICAL, "ERROR: Directive 'refresh_stale_hit' is obsolete.");
        debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "refresh_stale_hit : This option is not yet supported by Squid-3.");
        parse_obsolete(token);
        return 1;
    };
    if (!strcmp(token, "storeurl_access")) {
        debugs(0, DBG_CRITICAL, "ERROR: Directive 'storeurl_access' is obsolete.");
        debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "storeurl_access : This option is not yet supported by this version of Squid-3. Please try a later release.");
        parse_obsolete(token);
        return 1;
    };
    if (!strcmp(token, "storeurl_rewrite_children")) {
        debugs(0, DBG_CRITICAL, "ERROR: Directive 'storeurl_rewrite_children' is obsolete.");
        debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "storeurl_rewrite_children : This option is not yet supported by this version of Squid-3. Please try a later release.");
        parse_obsolete(token);
        return 1;
    };
    if (!strcmp(token, "storeurl_rewrite_concurrency")) {
        debugs(0, DBG_CRITICAL, "ERROR: Directive 'storeurl_rewrite_concurrency' is obsolete.");
        debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "storeurl_rewrite_concurrency : This option is not yet supported by this version of Squid-3. Please try a later release.");
        parse_obsolete(token);
        return 1;
    };
    if (!strcmp(token, "storeurl_rewrite_program")) {
        debugs(0, DBG_CRITICAL, "ERROR: Directive 'storeurl_rewrite_program' is obsolete.");
        debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "storeurl_rewrite_program : This option is not yet supported by this version of Squid-3. Please try a later release.");
        parse_obsolete(token);
        return 1;
    };
    if (!strcmp(token, "ignore_expect_100")) {
        debugs(0, DBG_CRITICAL, "ERROR: Directive 'ignore_expect_100' is obsolete.");
        debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ignore_expect_100 : Remove this line. The HTTP/1.1 feature is now fully supported by default.");
        parse_obsolete(token);
        return 1;
    };
    if (!strcmp(token, "dns_v4_fallback")) {
        debugs(0, DBG_CRITICAL, "ERROR: Directive 'dns_v4_fallback' is obsolete.");
        debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "dns_v4_fallback : Remove this line. Squid performs a 'Happy Eyeballs' algorithm, the 'fallback' algorithm is no longer relevant.");
        parse_obsolete(token);
        return 1;
    };
    if (!strcmp(token, "ftp_list_width")) {
        debugs(0, DBG_CRITICAL, "ERROR: Directive 'ftp_list_width' is obsolete.");
        debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ftp_list_width : Remove this line. Configure FTP page display using the CSS controls in errorpages.css instead.");
        parse_obsolete(token);
        return 1;
    };
    if (!strcmp(token, "maximum_single_addr_tries")) {
        debugs(0, DBG_CRITICAL, "ERROR: Directive 'maximum_single_addr_tries' is obsolete.");
        debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "maximum_single_addr_tries : Replaced by connect_retries. The behaviour has changed, please read the documentation before altering.");
        parse_obsolete(token);
        return 1;
    };
    if (!strcmp(token, "update_headers")) {
        debugs(0, DBG_CRITICAL, "ERROR: Directive 'update_headers' is obsolete.");
        debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "update_headers : Remove this line. The feature is supported by default in storage types where update is implemented.");
        parse_obsolete(token);
        return 1;
    };
    if (!strcmp(token, "url_rewrite_concurrency")) {
        debugs(0, DBG_CRITICAL, "ERROR: Directive 'url_rewrite_concurrency' is obsolete.");
        debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "url_rewrite_concurrency : Remove this line. Set the 'concurrency=' option of url_rewrite_children instead.");
        parse_obsolete(token);
        return 1;
    };
    if (!strcmp(token, "dns_testnames")) {
        debugs(0, DBG_CRITICAL, "ERROR: Directive 'dns_testnames' is obsolete.");
        debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "dns_testnames : Remove this line. DNS is no longer tested on startup.");
        parse_obsolete(token);
        return 1;
    };
    if (!strcmp(token, "extension_methods")) {
        debugs(0, DBG_CRITICAL, "ERROR: Directive 'extension_methods' is obsolete.");
        debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "extension_methods : Remove this line. All valid methods for HTTP are accepted by default.");
        parse_obsolete(token);
        return 1;
    };
    if (!strcmp(token, "zero_buffers")) {
        debugs(0, DBG_CRITICAL, "ERROR: Directive 'zero_buffers' is obsolete.");
        parse_obsolete(token);
        return 1;
    };
    if (!strcmp(token, "incoming_rate")) {
        debugs(0, DBG_CRITICAL, "ERROR: Directive 'incoming_rate' is obsolete.");
        parse_obsolete(token);
        return 1;
    };
    if (!strcmp(token, "server_http11")) {
        debugs(0, DBG_CRITICAL, "ERROR: Directive 'server_http11' is obsolete.");
        debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "server_http11 : Remove this line. HTTP/1.1 is supported by default.");
        parse_obsolete(token);
        return 1;
    };
    if (!strcmp(token, "upgrade_http0.9")) {
        debugs(0, DBG_CRITICAL, "ERROR: Directive 'upgrade_http0.9' is obsolete.");
        debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "upgrade_http0.9 : Remove this line. ICY/1.0 streaming protocol is supported by default.");
        parse_obsolete(token);
        return 1;
    };
    if (!strcmp(token, "zph_local")) {
        debugs(0, DBG_CRITICAL, "ERROR: Directive 'zph_local' is obsolete.");
        debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "zph_local : Alter these entries. Use the qos_flows directive instead.");
        parse_obsolete(token);
        return 1;
    };
    if (!strcmp(token, "zph_sibling")) {
        debugs(0, DBG_CRITICAL, "ERROR: Directive 'zph_sibling' is obsolete.");
        debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "zph_sibling : Alter these entries. Use the qos_flows directive instead.");
        parse_obsolete(token);
        return 1;
    };
    if (!strcmp(token, "zph_parent")) {
        debugs(0, DBG_CRITICAL, "ERROR: Directive 'zph_parent' is obsolete.");
        debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "zph_parent : Alter these entries. Use the qos_flows directive instead.");
        parse_obsolete(token);
        return 1;
    };
    if (!strcmp(token, "zph_option")) {
        debugs(0, DBG_CRITICAL, "ERROR: Directive 'zph_option' is obsolete.");
        debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "zph_option : Alter these entries. Use the qos_flows directive instead.");
        parse_obsolete(token);
        return 1;
    };
    if (!strcmp(token, "zph_mode")) {
        debugs(0, DBG_CRITICAL, "ERROR: Directive 'zph_mode' is obsolete.");
        debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "zph_mode : Alter these entries. Use the qos_flows directive instead.");
        parse_obsolete(token);
        return 1;
    };
    if (!strcmp(token, "header_access")) {
        debugs(0, DBG_CRITICAL, "ERROR: Directive 'header_access' is obsolete.");
        debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "header_access : Since squid-3.0 replace with request_header_access or reply_header_access");
        debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "header_access : depending on whether you wish to match client requests or server replies.");
        parse_obsolete(token);
        return 1;
    };
    if (!strcmp(token, "httpd_accel_no_pmtu_disc")) {
        debugs(0, DBG_CRITICAL, "ERROR: Directive 'httpd_accel_no_pmtu_disc' is obsolete.");
        debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "httpd_accel_no_pmtu_disc : Since squid-3.0 use the 'disable-pmtu-discovery' flag on http_port instead.");
        parse_obsolete(token);
        return 1;
    };
    if (!strcmp(token, "wais_relay_host")) {
        debugs(0, DBG_CRITICAL, "ERROR: Directive 'wais_relay_host' is obsolete.");
        debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "wais_relay_host : Replace this line with 'cache_peer' configuration.");
        parse_obsolete(token);
        return 1;
    };
    if (!strcmp(token, "wais_relay_port")) {
        debugs(0, DBG_CRITICAL, "ERROR: Directive 'wais_relay_port' is obsolete.");
        debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "wais_relay_port : Replace this line with 'cache_peer' configuration.");
        parse_obsolete(token);
        return 1;
    };
    if (!strcmp(token, "auth_param")) {
#if USE_AUTH
        parse_authparam(&Auth::TheConfig);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'auth_param' requires --enable-auth");
#endif
        return 1;
    };
    if (!strcmp(token, "authenticate_cache_garbage_interval")) {
        parse_time_t(&Config.authenticateGCInterval);
        return 1;
    };
    if (!strcmp(token, "authenticate_ttl")) {
        parse_time_t(&Config.authenticateTTL);
        return 1;
    };
    if (!strcmp(token, "authenticate_ip_ttl")) {
        parse_time_t(&Config.authenticateIpTTL);
        return 1;
    };
    if (!strcmp(token, "external_acl_type")) {
        parse_externalAclHelper(&Config.externalAclHelperList);
        return 1;
    };
    if (!strcmp(token, "acl")) {
        parse_acl(&Config.aclList);
        return 1;
    };
    if (!strcmp(token, "follow_x_forwarded_for")) {
#if FOLLOW_X_FORWARDED_FOR
        parse_acl_access(&Config.accessList.followXFF);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'follow_x_forwarded_for' requires --enable-follow-x-forwarded-for");
#endif
        return 1;
    };
    if (!strcmp(token, "acl_uses_indirect_client")) {
#if FOLLOW_X_FORWARDED_FOR
        parse_onoff(&Config.onoff.acl_uses_indirect_client);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'acl_uses_indirect_client' requires --enable-follow-x-forwarded-for");
#endif
        return 1;
    };
    if (!strcmp(token, "delay_pool_uses_indirect_client")) {
#if FOLLOW_X_FORWARDED_FOR&&USE_DELAY_POOLS
        parse_onoff(&Config.onoff.delay_pool_uses_indirect_client);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'delay_pool_uses_indirect_client' requires --enable-follow-x-forwarded-for and --enable-delay-pools");
#endif
        return 1;
    };
    if (!strcmp(token, "log_uses_indirect_client")) {
#if FOLLOW_X_FORWARDED_FOR
        parse_onoff(&Config.onoff.log_uses_indirect_client);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'log_uses_indirect_client' requires --enable-follow-x-forwarded-for");
#endif
        return 1;
    };
    if (!strcmp(token, "tproxy_uses_indirect_client")) {
#if FOLLOW_X_FORWARDED_FOR&&LINUX_NETFILTER
        parse_onoff(&Config.onoff.tproxy_uses_indirect_client);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'tproxy_uses_indirect_client' requires --enable-follow-x-forwarded-for and --enable-linux-netfilter");
#endif
        return 1;
    };
    if (!strcmp(token, "http_access")) {
        parse_acl_access(&Config.accessList.http);
        return 1;
    };
    if (!strcmp(token, "adapted_http_access")) {
        parse_acl_access(&Config.accessList.adapted_http);
        return 1;
    };
    if (!strcmp(token, "http_access2")) {
        parse_acl_access(&Config.accessList.adapted_http);
        return 1;
    };
    if (!strcmp(token, "http_reply_access")) {
        parse_acl_access(&Config.accessList.reply);
        return 1;
    };
    if (!strcmp(token, "icp_access")) {
        parse_acl_access(&Config.accessList.icp);
        return 1;
    };
    if (!strcmp(token, "htcp_access")) {
#if USE_HTCP
        parse_acl_access(&Config.accessList.htcp);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'htcp_access' requires --enable-htcp");
#endif
        return 1;
    };
    if (!strcmp(token, "htcp_clr_access")) {
#if USE_HTCP
        parse_acl_access(&Config.accessList.htcp_clr);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'htcp_clr_access' requires --enable-htcp");
#endif
        return 1;
    };
    if (!strcmp(token, "miss_access")) {
        parse_acl_access(&Config.accessList.miss);
        return 1;
    };
    if (!strcmp(token, "ident_lookup_access")) {
#if USE_IDENT
        parse_acl_access(&Ident::TheConfig.identLookup);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'ident_lookup_access' requires --enable-ident-lookups");
#endif
        return 1;
    };
    if (!strcmp(token, "reply_body_max_size")) {
        parse_acl_b_size_t(&Config.ReplyBodySize);
        return 1;
    };
    if (!strcmp(token, "http_port")) {
        parse_PortCfg(&Config.Sockaddr.http);
        return 1;
    };
    if (!strcmp(token, "ascii_port")) {
        parse_PortCfg(&Config.Sockaddr.http);
        return 1;
    };
    if (!strcmp(token, "https_port")) {
#if USE_SSL
        parse_PortCfg(&Config.Sockaddr.https);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'https_port' requires --enable-ssl");
#endif
        return 1;
    };
    if (!strcmp(token, "tcp_outgoing_tos")) {
        parse_acl_tos(&Ip::Qos::TheConfig.tosToServer);
        return 1;
    };
    if (!strcmp(token, "tcp_outgoing_dscp")) {
        parse_acl_tos(&Ip::Qos::TheConfig.tosToServer);
        return 1;
    };
    if (!strcmp(token, "tcp_outgoing_ds")) {
        parse_acl_tos(&Ip::Qos::TheConfig.tosToServer);
        return 1;
    };
    if (!strcmp(token, "clientside_tos")) {
        parse_acl_tos(&Ip::Qos::TheConfig.tosToClient);
        return 1;
    };
    if (!strcmp(token, "tcp_outgoing_mark")) {
#if SO_MARK&&USE_LIBCAP
        parse_acl_nfmark(&Ip::Qos::TheConfig.nfmarkToServer);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'tcp_outgoing_mark' requires Packet MARK (Linux)");
#endif
        return 1;
    };
    if (!strcmp(token, "clientside_mark")) {
#if SO_MARK&&USE_LIBCAP
        parse_acl_nfmark(&Ip::Qos::TheConfig.nfmarkToClient);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'clientside_mark' requires Packet MARK (Linux)");
#endif
        return 1;
    };
    if (!strcmp(token, "qos_flows")) {
#if USE_QOS_TOS
        parse_QosConfig(&Ip::Qos::TheConfig);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'qos_flows' requires --enable-zph-qos");
#endif
        return 1;
    };
    if (!strcmp(token, "tcp_outgoing_address")) {
        parse_acl_address(&Config.accessList.outgoing_address);
        return 1;
    };
    if (!strcmp(token, "host_verify_strict")) {
        parse_onoff(&Config.onoff.hostStrictVerify);
        return 1;
    };
    if (!strcmp(token, "client_dst_passthru")) {
        parse_onoff(&Config.onoff.client_dst_passthru);
        return 1;
    };
    if (!strcmp(token, "ssl_unclean_shutdown")) {
#if USE_SSL
        parse_onoff(&Config.SSL.unclean_shutdown);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'ssl_unclean_shutdown' requires --enable-ssl");
#endif
        return 1;
    };
    if (!strcmp(token, "ssl_engine")) {
#if USE_SSL
        parse_string(&Config.SSL.ssl_engine);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'ssl_engine' requires --enable-ssl");
#endif
        return 1;
    };
    if (!strcmp(token, "sslproxy_client_certificate")) {
#if USE_SSL
        parse_string(&Config.ssl_client.cert);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'sslproxy_client_certificate' requires --enable-ssl");
#endif
        return 1;
    };
    if (!strcmp(token, "sslproxy_client_key")) {
#if USE_SSL
        parse_string(&Config.ssl_client.key);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'sslproxy_client_key' requires --enable-ssl");
#endif
        return 1;
    };
    if (!strcmp(token, "sslproxy_version")) {
#if USE_SSL
        parse_int(&Config.ssl_client.version);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'sslproxy_version' requires --enable-ssl");
#endif
        return 1;
    };
    if (!strcmp(token, "sslproxy_options")) {
#if USE_SSL
        parse_string(&Config.ssl_client.options);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'sslproxy_options' requires --enable-ssl");
#endif
        return 1;
    };
    if (!strcmp(token, "sslproxy_cipher")) {
#if USE_SSL
        parse_string(&Config.ssl_client.cipher);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'sslproxy_cipher' requires --enable-ssl");
#endif
        return 1;
    };
    if (!strcmp(token, "sslproxy_cafile")) {
#if USE_SSL
        parse_string(&Config.ssl_client.cafile);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'sslproxy_cafile' requires --enable-ssl");
#endif
        return 1;
    };
    if (!strcmp(token, "sslproxy_capath")) {
#if USE_SSL
        parse_string(&Config.ssl_client.capath);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'sslproxy_capath' requires --enable-ssl");
#endif
        return 1;
    };
    if (!strcmp(token, "ssl_bump")) {
#if USE_SSL
        parse_sslproxy_ssl_bump(&Config.accessList.ssl_bump);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'ssl_bump' requires --enable-ssl");
#endif
        return 1;
    };
    if (!strcmp(token, "sslproxy_flags")) {
#if USE_SSL
        parse_string(&Config.ssl_client.flags);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'sslproxy_flags' requires --enable-ssl");
#endif
        return 1;
    };
    if (!strcmp(token, "sslproxy_cert_error")) {
#if USE_SSL
        parse_acl_access(&Config.ssl_client.cert_error);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'sslproxy_cert_error' requires --enable-ssl");
#endif
        return 1;
    };
    if (!strcmp(token, "sslproxy_cert_sign")) {
#if USE_SSL
        parse_sslproxy_cert_sign(&Config.ssl_client.cert_sign);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'sslproxy_cert_sign' requires --enable-ssl");
#endif
        return 1;
    };
    if (!strcmp(token, "sslproxy_cert_adapt")) {
#if USE_SSL
        parse_sslproxy_cert_adapt(&Config.ssl_client.cert_adapt);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'sslproxy_cert_adapt' requires --enable-ssl");
#endif
        return 1;
    };
    if (!strcmp(token, "sslpassword_program")) {
#if USE_SSL
        parse_string(&Config.Program.ssl_password);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'sslpassword_program' requires --enable-ssl");
#endif
        return 1;
    };
    if (!strcmp(token, "sslcrtd_program")) {
#if USE_SSL_CRTD
        parse_eol(&Ssl::TheConfig.ssl_crtd);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'sslcrtd_program' requires --enable-ssl-crtd");
#endif
        return 1;
    };
    if (!strcmp(token, "sslcrtd_children")) {
#if USE_SSL_CRTD
        parse_HelperChildConfig(&Ssl::TheConfig.ssl_crtdChildren);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'sslcrtd_children' requires --enable-ssl-crtd");
#endif
        return 1;
    };
    if (!strcmp(token, "cache_peer")) {
        parse_peer(&Config.peers);
        return 1;
    };
    if (!strcmp(token, "cache_peer_domain")) {
        parse_hostdomain();
        return 1;
    };
    if (!strcmp(token, "cache_host_domain")) {
        parse_hostdomain();
        return 1;
    };
    if (!strcmp(token, "cache_peer_access")) {
        parse_peer_access();
        return 1;
    };
    if (!strcmp(token, "neighbor_type_domain")) {
        parse_hostdomaintype();
        return 1;
    };
    if (!strcmp(token, "dead_peer_timeout")) {
        parse_time_t(&Config.Timeout.deadPeer);
        return 1;
    };
    if (!strcmp(token, "forward_max_tries")) {
        parse_int(&Config.forward_max_tries);
        return 1;
    };
    if (!strcmp(token, "hierarchy_stoplist")) {
        parse_wordlist(&Config.hierarchy_stoplist);
        return 1;
    };
    if (!strcmp(token, "cache_mem")) {
        parse_b_size_t(&Config.memMaxSize);
        return 1;
    };
    if (!strcmp(token, "maximum_object_size_in_memory")) {
        parse_b_size_t(&Config.Store.maxInMemObjSize);
        return 1;
    };
    if (!strcmp(token, "memory_cache_shared")) {
        parse_YesNoNone(&Config.memShared);
        return 1;
    };
    if (!strcmp(token, "memory_cache_mode")) {
        parse_memcachemode(&Config);
        return 1;
    };
    if (!strcmp(token, "memory_replacement_policy")) {
        parse_removalpolicy(&Config.memPolicy);
        return 1;
    };
    if (!strcmp(token, "cache_replacement_policy")) {
        parse_removalpolicy(&Config.replPolicy);
        return 1;
    };
    if (!strcmp(token, "cache_dir")) {
        parse_cachedir(&Config.cacheSwap);
        return 1;
    };
    if (!strcmp(token, "store_dir_select_algorithm")) {
        parse_string(&Config.store_dir_select_algorithm);
        return 1;
    };
    if (!strcmp(token, "max_open_disk_fds")) {
        parse_int(&Config.max_open_disk_fds);
        return 1;
    };
    if (!strcmp(token, "minimum_object_size")) {
        parse_b_int64_t(&Config.Store.minObjectSize);
        return 1;
    };
    if (!strcmp(token, "maximum_object_size")) {
        parse_b_int64_t(&Config.Store.maxObjectSize);
        return 1;
    };
    if (!strcmp(token, "cache_swap_low")) {
        parse_int(&Config.Swap.lowWaterMark);
        return 1;
    };
    if (!strcmp(token, "cache_swap_high")) {
        parse_int(&Config.Swap.highWaterMark);
        return 1;
    };
    if (!strcmp(token, "logformat")) {
        parse_logformat(&Log::TheConfig);
        return 1;
    };
    if (!strcmp(token, "access_log")) {
        parse_access_log(&Config.Log.accesslogs);
        return 1;
    };
    if (!strcmp(token, "cache_access_log")) {
        parse_access_log(&Config.Log.accesslogs);
        return 1;
    };
    if (!strcmp(token, "icap_log")) {
#if ICAP_CLIENT
        parse_access_log(&Config.Log.icaplogs);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'icap_log' requires --enable-icap-client");
#endif
        return 1;
    };
    if (!strcmp(token, "logfile_daemon")) {
        parse_string(&Log::TheConfig.logfile_daemon);
        return 1;
    };
    if (!strcmp(token, "log_access")) {
        parse_acl_access(&Config.accessList.log);
        return 1;
    };
    if (!strcmp(token, "log_icap")) {
#if ICAP_CLIENT
        parse_acl_access(&Config.accessList.icap);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'log_icap' requires --enable-icap-client");
#endif
        return 1;
    };
    if (!strcmp(token, "cache_store_log")) {
        parse_string(&Config.Log.store);
        return 1;
    };
    if (!strcmp(token, "cache_swap_state")) {
        parse_string(&Config.Log.swap);
        return 1;
    };
    if (!strcmp(token, "cache_swap_log")) {
        parse_string(&Config.Log.swap);
        return 1;
    };
    if (!strcmp(token, "logfile_rotate")) {
        parse_int(&Config.Log.rotateNumber);
        return 1;
    };
    if (!strcmp(token, "emulate_httpd_log")) {
        debugs(0, DBG_CRITICAL, "ERROR: Directive 'emulate_httpd_log' is obsolete.");
        debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "emulate_httpd_log : Replace this with an access_log directive using the format 'common' or 'combined'.");
        parse_obsolete(token);
        return 1;
    };
    if (!strcmp(token, "log_ip_on_direct")) {
        debugs(0, DBG_CRITICAL, "ERROR: Directive 'log_ip_on_direct' is obsolete.");
        debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "log_ip_on_direct : Remove this option from your config. To log server or peer names use %<A in the log format.");
        parse_obsolete(token);
        return 1;
    };
    if (!strcmp(token, "mime_table")) {
        parse_string(&Config.mimeTablePathname);
        return 1;
    };
    if (!strcmp(token, "log_mime_hdrs")) {
        parse_onoff(&Config.onoff.log_mime_hdrs);
        return 1;
    };
    if (!strcmp(token, "useragent_log")) {
        debugs(0, DBG_CRITICAL, "ERROR: Directive 'useragent_log' is obsolete.");
        debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "useragent_log : Replace this with an access_log directive using the format 'useragent'.");
        parse_obsolete(token);
        return 1;
    };
    if (!strcmp(token, "referer_log")) {
        debugs(0, DBG_CRITICAL, "ERROR: Directive 'referer_log' is obsolete.");
        debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "referer_log : Replace this with an access_log directive using the format 'referrer'.");
        parse_obsolete(token);
        return 1;
    };
    if (!strcmp(token, "referrer_log")) {
        debugs(0, DBG_CRITICAL, "ERROR: Directive 'referrer_log' is obsolete.");
        debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "referrer_log : Replace this with an access_log directive using the format 'referrer'.");
        parse_obsolete(token);
        return 1;
    };
    if (!strcmp(token, "pid_filename")) {
        parse_string(&Config.pidFilename);
        return 1;
    };
    if (!strcmp(token, "log_fqdn")) {
        debugs(0, DBG_CRITICAL, "ERROR: Directive 'log_fqdn' is obsolete.");
        debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "log_fqdn : Remove this option from your config. To log FQDN use %>A in the log format.");
        parse_obsolete(token);
        return 1;
    };
    if (!strcmp(token, "client_netmask")) {
        parse_address(&Config.Addrs.client_netmask);
        return 1;
    };
    if (!strcmp(token, "forward_log")) {
        debugs(0, DBG_CRITICAL, "ERROR: Directive 'forward_log' is obsolete.");
        debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "forward_log : Use a regular access.log with ACL limiting it to MISS events.");
        parse_obsolete(token);
        return 1;
    };
    if (!strcmp(token, "strip_query_terms")) {
        parse_onoff(&Config.onoff.strip_query_terms);
        return 1;
    };
    if (!strcmp(token, "buffered_logs")) {
        parse_onoff(&Config.onoff.buffered_logs);
        return 1;
    };
    if (!strcmp(token, "netdb_filename")) {
#if USE_ICMP
        parse_string(&Config.netdbFilename);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'netdb_filename' requires --enable-icmp");
#endif
        return 1;
    };
    if (!strcmp(token, "cache_log")) {
        parse_string(&Debug::cache_log);
        return 1;
    };
    if (!strcmp(token, "debug_options")) {
        parse_eol(&Debug::debugOptions);
        return 1;
    };
    if (!strcmp(token, "coredump_dir")) {
        parse_string(&Config.coredump_dir);
        return 1;
    };
    if (!strcmp(token, "ftp_user")) {
        parse_string(&Config.Ftp.anon_user);
        return 1;
    };
    if (!strcmp(token, "ftp_passive")) {
        parse_onoff(&Config.Ftp.passive);
        return 1;
    };
    if (!strcmp(token, "ftp_epsv_all")) {
        parse_onoff(&Config.Ftp.epsv_all);
        return 1;
    };
    if (!strcmp(token, "ftp_epsv")) {
        parse_onoff(&Config.Ftp.epsv);
        return 1;
    };
    if (!strcmp(token, "ftp_eprt")) {
        parse_onoff(&Config.Ftp.eprt);
        return 1;
    };
    if (!strcmp(token, "ftp_sanitycheck")) {
        parse_onoff(&Config.Ftp.sanitycheck);
        return 1;
    };
    if (!strcmp(token, "ftp_telnet_protocol")) {
        parse_onoff(&Config.Ftp.telnet);
        return 1;
    };
    if (!strcmp(token, "diskd_program")) {
        parse_string(&Config.Program.diskd);
        return 1;
    };
    if (!strcmp(token, "unlinkd_program")) {
#if USE_UNLINKD
        parse_string(&Config.Program.unlinkd);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'unlinkd_program' requires --enable-unlinkd");
#endif
        return 1;
    };
    if (!strcmp(token, "pinger_program")) {
#if USE_ICMP
        parse_string(&Config.pinger.program);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'pinger_program' requires --enable-icmp");
#endif
        return 1;
    };
    if (!strcmp(token, "pinger_enable")) {
#if USE_ICMP
        parse_onoff(&Config.pinger.enable);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'pinger_enable' requires --enable-icmp");
#endif
        return 1;
    };
    if (!strcmp(token, "url_rewrite_program")) {
        parse_wordlist(&Config.Program.redirect);
        return 1;
    };
    if (!strcmp(token, "redirect_program")) {
        parse_wordlist(&Config.Program.redirect);
        return 1;
    };
    if (!strcmp(token, "url_rewrite_children")) {
        parse_HelperChildConfig(&Config.redirectChildren);
        return 1;
    };
    if (!strcmp(token, "redirect_children")) {
        parse_HelperChildConfig(&Config.redirectChildren);
        return 1;
    };
    if (!strcmp(token, "url_rewrite_host_header")) {
        parse_onoff(&Config.onoff.redir_rewrites_host);
        return 1;
    };
    if (!strcmp(token, "redirect_rewrites_host_header")) {
        parse_onoff(&Config.onoff.redir_rewrites_host);
        return 1;
    };
    if (!strcmp(token, "url_rewrite_access")) {
        parse_acl_access(&Config.accessList.redirector);
        return 1;
    };
    if (!strcmp(token, "redirector_access")) {
        parse_acl_access(&Config.accessList.redirector);
        return 1;
    };
    if (!strcmp(token, "url_rewrite_bypass")) {
        parse_onoff(&Config.onoff.redirector_bypass);
        return 1;
    };
    if (!strcmp(token, "redirector_bypass")) {
        parse_onoff(&Config.onoff.redirector_bypass);
        return 1;
    };
    if (!strcmp(token, "cache")) {
        parse_acl_access(&Config.accessList.noCache);
        return 1;
    };
    if (!strcmp(token, "no_cache")) {
        parse_acl_access(&Config.accessList.noCache);
        return 1;
    };
    if (!strcmp(token, "max_stale")) {
        parse_time_t(&Config.maxStale);
        return 1;
    };
    if (!strcmp(token, "refresh_pattern")) {
        parse_refreshpattern(&Config.Refresh);
        return 1;
    };
    if (!strcmp(token, "quick_abort_min")) {
        parse_kb_int64_t(&Config.quickAbort.min);
        return 1;
    };
    if (!strcmp(token, "quick_abort_max")) {
        parse_kb_int64_t(&Config.quickAbort.max);
        return 1;
    };
    if (!strcmp(token, "quick_abort_pct")) {
        parse_int(&Config.quickAbort.pct);
        return 1;
    };
    if (!strcmp(token, "read_ahead_gap")) {
        parse_b_int64_t(&Config.readAheadGap);
        return 1;
    };
    if (!strcmp(token, "negative_ttl")) {
#if USE_HTTP_VIOLATIONS
        parse_time_t(&Config.negativeTtl);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'negative_ttl' requires --enable-http-violations");
#endif
        return 1;
    };
    if (!strcmp(token, "positive_dns_ttl")) {
        parse_time_t(&Config.positiveDnsTtl);
        return 1;
    };
    if (!strcmp(token, "negative_dns_ttl")) {
        parse_time_t(&Config.negativeDnsTtl);
        return 1;
    };
    if (!strcmp(token, "range_offset_limit")) {
        parse_acl_b_size_t(&Config.rangeOffsetLimit);
        return 1;
    };
    if (!strcmp(token, "minimum_expiry_time")) {
        parse_time_t(&Config.minimum_expiry_time);
        return 1;
    };
    if (!strcmp(token, "store_avg_object_size")) {
        parse_b_int64_t(&Config.Store.avgObjectSize);
        return 1;
    };
    if (!strcmp(token, "store_objects_per_bucket")) {
        parse_int(&Config.Store.objectsPerBucket);
        return 1;
    };
    if (!strcmp(token, "request_header_max_size")) {
        parse_b_size_t(&Config.maxRequestHeaderSize);
        return 1;
    };
    if (!strcmp(token, "reply_header_max_size")) {
        parse_b_size_t(&Config.maxReplyHeaderSize);
        return 1;
    };
    if (!strcmp(token, "request_body_max_size")) {
        parse_b_int64_t(&Config.maxRequestBodySize);
        return 1;
    };
    if (!strcmp(token, "client_request_buffer_max_size")) {
        parse_b_size_t(&Config.maxRequestBufferSize);
        return 1;
    };
    if (!strcmp(token, "chunked_request_body_max_size")) {
        parse_b_int64_t(&Config.maxChunkedRequestBodySize);
        return 1;
    };
    if (!strcmp(token, "broken_posts")) {
#if USE_HTTP_VIOLATIONS
        parse_acl_access(&Config.accessList.brokenPosts);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'broken_posts' requires --enable-http-violations");
#endif
        return 1;
    };
    if (!strcmp(token, "adaptation_uses_indirect_client")) {
#if FOLLOW_X_FORWARDED_FOR&&USE_ADAPTATION
        parse_onoff(&Adaptation::Config::use_indirect_client);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'adaptation_uses_indirect_client' requires --enable-follow-x-forwarded-for and (--enable-icap-client and/or --enable-ecap)");
#endif
        return 1;
    };
    if (!strcmp(token, "icap_uses_indirect_client")) {
#if FOLLOW_X_FORWARDED_FOR&&USE_ADAPTATION
        parse_onoff(&Adaptation::Config::use_indirect_client);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'adaptation_uses_indirect_client' requires --enable-follow-x-forwarded-for and (--enable-icap-client and/or --enable-ecap)");
#endif
        return 1;
    };
    if (!strcmp(token, "via")) {
#if USE_HTTP_VIOLATIONS
        parse_onoff(&Config.onoff.via);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'via' requires --enable-http-violations");
#endif
        return 1;
    };
    if (!strcmp(token, "ie_refresh")) {
        parse_onoff(&Config.onoff.ie_refresh);
        return 1;
    };
    if (!strcmp(token, "vary_ignore_expire")) {
        parse_onoff(&Config.onoff.vary_ignore_expire);
        return 1;
    };
    if (!strcmp(token, "request_entities")) {
        parse_onoff(&Config.onoff.request_entities);
        return 1;
    };
    if (!strcmp(token, "request_header_access")) {
#if USE_HTTP_VIOLATIONS
        parse_http_header_access(&Config.request_header_access);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'request_header_access' requires --enable-http-violations");
#endif
        return 1;
    };
    if (!strcmp(token, "reply_header_access")) {
#if USE_HTTP_VIOLATIONS
        parse_http_header_access(&Config.reply_header_access);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'reply_header_access' requires --enable-http-violations");
#endif
        return 1;
    };
    if (!strcmp(token, "request_header_replace")) {
#if USE_HTTP_VIOLATIONS
        parse_http_header_replace(&Config.request_header_access);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'request_header_replace' requires --enable-http-violations");
#endif
        return 1;
    };
    if (!strcmp(token, "header_replace")) {
#if USE_HTTP_VIOLATIONS
        parse_http_header_replace(&Config.request_header_access);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'request_header_replace' requires --enable-http-violations");
#endif
        return 1;
    };
    if (!strcmp(token, "reply_header_replace")) {
#if USE_HTTP_VIOLATIONS
        parse_http_header_replace(&Config.reply_header_access);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'reply_header_replace' requires --enable-http-violations");
#endif
        return 1;
    };
    if (!strcmp(token, "request_header_add")) {
        parse_HeaderWithAclList(&Config.request_header_add);
        return 1;
    };
    if (!strcmp(token, "relaxed_header_parser")) {
        parse_tristate(&Config.onoff.relaxed_header_parser);
        return 1;
    };
    if (!strcmp(token, "forward_timeout")) {
        parse_time_t(&Config.Timeout.forward);
        return 1;
    };
    if (!strcmp(token, "connect_timeout")) {
        parse_time_t(&Config.Timeout.connect);
        return 1;
    };
    if (!strcmp(token, "peer_connect_timeout")) {
        parse_time_t(&Config.Timeout.peer_connect);
        return 1;
    };
    if (!strcmp(token, "read_timeout")) {
        parse_time_t(&Config.Timeout.read);
        return 1;
    };
    if (!strcmp(token, "write_timeout")) {
        parse_time_t(&Config.Timeout.write);
        return 1;
    };
    if (!strcmp(token, "request_timeout")) {
        parse_time_t(&Config.Timeout.request);
        return 1;
    };
    if (!strcmp(token, "client_idle_pconn_timeout")) {
        parse_time_t(&Config.Timeout.clientIdlePconn);
        return 1;
    };
    if (!strcmp(token, "persistent_request_timeout")) {
        parse_time_t(&Config.Timeout.clientIdlePconn);
        return 1;
    };
    if (!strcmp(token, "client_lifetime")) {
        parse_time_t(&Config.Timeout.lifetime);
        return 1;
    };
    if (!strcmp(token, "half_closed_clients")) {
        parse_onoff(&Config.onoff.half_closed_clients);
        return 1;
    };
    if (!strcmp(token, "server_idle_pconn_timeout")) {
        parse_time_t(&Config.Timeout.serverIdlePconn);
        return 1;
    };
    if (!strcmp(token, "pconn_timeout")) {
        parse_time_t(&Config.Timeout.serverIdlePconn);
        return 1;
    };
    if (!strcmp(token, "ident_timeout")) {
#if USE_IDENT
        parse_time_t(&Ident::TheConfig.timeout);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'ident_timeout' requires --enable-ident-lookups");
#endif
        return 1;
    };
    if (!strcmp(token, "shutdown_lifetime")) {
        parse_time_t(&Config.shutdownLifetime);
        return 1;
    };
    if (!strcmp(token, "cache_mgr")) {
        parse_string(&Config.adminEmail);
        return 1;
    };
    if (!strcmp(token, "mail_from")) {
        parse_string(&Config.EmailFrom);
        return 1;
    };
    if (!strcmp(token, "mail_program")) {
        parse_eol(&Config.EmailProgram);
        return 1;
    };
    if (!strcmp(token, "cache_effective_user")) {
        parse_string(&Config.effectiveUser);
        return 1;
    };
    if (!strcmp(token, "cache_effective_group")) {
        parse_string(&Config.effectiveGroup);
        return 1;
    };
    if (!strcmp(token, "httpd_suppress_version_string")) {
        parse_onoff(&Config.onoff.httpd_suppress_version_string);
        return 1;
    };
    if (!strcmp(token, "visible_hostname")) {
        parse_string(&Config.visibleHostname);
        return 1;
    };
    if (!strcmp(token, "unique_hostname")) {
        parse_string(&Config.uniqueHostname);
        return 1;
    };
    if (!strcmp(token, "hostname_aliases")) {
        parse_wordlist(&Config.hostnameAliases);
        return 1;
    };
    if (!strcmp(token, "umask")) {
        parse_int(&Config.umask);
        return 1;
    };
    if (!strcmp(token, "announce_period")) {
        parse_time_t(&Config.Announce.period);
        return 1;
    };
    if (!strcmp(token, "announce_host")) {
        parse_string(&Config.Announce.host);
        return 1;
    };
    if (!strcmp(token, "announce_file")) {
        parse_string(&Config.Announce.file);
        return 1;
    };
    if (!strcmp(token, "announce_port")) {
        parse_u_short(&Config.Announce.port);
        return 1;
    };
    if (!strcmp(token, "httpd_accel_surrogate_id")) {
        parse_string(&Config.Accel.surrogate_id);
        return 1;
    };
    if (!strcmp(token, "http_accel_surrogate_remote")) {
        parse_onoff(&Config.onoff.surrogate_is_remote);
        return 1;
    };
    if (!strcmp(token, "esi_parser")) {
#if USE_SQUID_ESI
        parse_string(&ESIParser::Type);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'esi_parser' requires --enable-esi");
#endif
        return 1;
    };
    if (!strcmp(token, "delay_pools")) {
#if USE_DELAY_POOLS
        parse_delay_pool_count(&Config.Delay);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'delay_pools' requires --enable-delay-pools");
#endif
        return 1;
    };
    if (!strcmp(token, "delay_class")) {
#if USE_DELAY_POOLS
        parse_delay_pool_class(&Config.Delay);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'delay_class' requires --enable-delay-pools");
#endif
        return 1;
    };
    if (!strcmp(token, "delay_access")) {
#if USE_DELAY_POOLS
        parse_delay_pool_access(&Config.Delay);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'delay_access' requires --enable-delay-pools");
#endif
        return 1;
    };
    if (!strcmp(token, "delay_parameters")) {
#if USE_DELAY_POOLS
        parse_delay_pool_rates(&Config.Delay);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'delay_parameters' requires --enable-delay-pools");
#endif
        return 1;
    };
    if (!strcmp(token, "delay_initial_bucket_level")) {
#if USE_DELAY_POOLS
        parse_u_short(&Config.Delay.initial);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'delay_initial_bucket_level' requires --enable-delay-pools");
#endif
        return 1;
    };
    if (!strcmp(token, "client_delay_pools")) {
#if USE_DELAY_POOLS
        parse_client_delay_pool_count(&Config.ClientDelay);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'client_delay_pools' requires --enable-delay-pools");
#endif
        return 1;
    };
    if (!strcmp(token, "client_delay_initial_bucket_level")) {
#if USE_DELAY_POOLS
        parse_u_short(&Config.ClientDelay.initial);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'client_delay_initial_bucket_level' requires --enable-delay-pools");
#endif
        return 1;
    };
    if (!strcmp(token, "client_delay_parameters")) {
#if USE_DELAY_POOLS
        parse_client_delay_pool_rates(&Config.ClientDelay);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'client_delay_parameters' requires --enable-delay-pools");
#endif
        return 1;
    };
    if (!strcmp(token, "client_delay_access")) {
#if USE_DELAY_POOLS
        parse_client_delay_pool_access(&Config.ClientDelay);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'client_delay_access' requires --enable-delay-pools");
#endif
        return 1;
    };
    if (!strcmp(token, "wccp_router")) {
#if USE_WCCP
        parse_address(&Config.Wccp.router);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'wccp_router' requires --enable-wccp");
#endif
        return 1;
    };
    if (!strcmp(token, "wccp2_router")) {
#if USE_WCCPv2
        parse_IpAddress_list(&Config.Wccp2.router);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'wccp2_router' requires --enable-wccpv2");
#endif
        return 1;
    };
    if (!strcmp(token, "wccp_version")) {
#if USE_WCCP
        parse_int(&Config.Wccp.version);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'wccp_version' requires --enable-wccp");
#endif
        return 1;
    };
    if (!strcmp(token, "wccp2_rebuild_wait")) {
#if USE_WCCPv2
        parse_onoff(&Config.Wccp2.rebuildwait);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'wccp2_rebuild_wait' requires --enable-wccpv2");
#endif
        return 1;
    };
    if (!strcmp(token, "wccp2_forwarding_method")) {
#if USE_WCCPv2
        parse_wccp2_method(&Config.Wccp2.forwarding_method);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'wccp2_forwarding_method' requires --enable-wccpv2");
#endif
        return 1;
    };
    if (!strcmp(token, "wccp2_return_method")) {
#if USE_WCCPv2
        parse_wccp2_method(&Config.Wccp2.return_method);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'wccp2_return_method' requires --enable-wccpv2");
#endif
        return 1;
    };
    if (!strcmp(token, "wccp2_assignment_method")) {
#if USE_WCCPv2
        parse_wccp2_amethod(&Config.Wccp2.assignment_method);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'wccp2_assignment_method' requires --enable-wccpv2");
#endif
        return 1;
    };
    if (!strcmp(token, "wccp2_service")) {
#if USE_WCCPv2
        parse_wccp2_service(&Config.Wccp2.info);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'wccp2_service' requires --enable-wccpv2");
#endif
        return 1;
    };
    if (!strcmp(token, "wccp2_service_info")) {
#if USE_WCCPv2
        parse_wccp2_service_info(&Config.Wccp2.info);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'wccp2_service_info' requires --enable-wccpv2");
#endif
        return 1;
    };
    if (!strcmp(token, "wccp2_weight")) {
#if USE_WCCPv2
        parse_int(&Config.Wccp2.weight);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'wccp2_weight' requires --enable-wccpv2");
#endif
        return 1;
    };
    if (!strcmp(token, "wccp_address")) {
#if USE_WCCP
        parse_address(&Config.Wccp.address);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'wccp_address' requires --enable-wccp");
#endif
        return 1;
    };
    if (!strcmp(token, "wccp2_address")) {
#if USE_WCCPv2
        parse_address(&Config.Wccp2.address);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'wccp2_address' requires --enable-wccpv2");
#endif
        return 1;
    };
    if (!strcmp(token, "client_persistent_connections")) {
        parse_onoff(&Config.onoff.client_pconns);
        return 1;
    };
    if (!strcmp(token, "server_persistent_connections")) {
        parse_onoff(&Config.onoff.server_pconns);
        return 1;
    };
    if (!strcmp(token, "persistent_connection_after_error")) {
        parse_onoff(&Config.onoff.error_pconns);
        return 1;
    };
    if (!strcmp(token, "detect_broken_pconn")) {
        parse_onoff(&Config.onoff.detect_broken_server_pconns);
        return 1;
    };
    if (!strcmp(token, "digest_generation")) {
#if USE_CACHE_DIGESTS
        parse_onoff(&Config.onoff.digest_generation);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'digest_generation' requires --enable-cache-digests");
#endif
        return 1;
    };
    if (!strcmp(token, "digest_bits_per_entry")) {
#if USE_CACHE_DIGESTS
        parse_int(&Config.digest.bits_per_entry);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'digest_bits_per_entry' requires --enable-cache-digests");
#endif
        return 1;
    };
    if (!strcmp(token, "digest_rebuild_period")) {
#if USE_CACHE_DIGESTS
        parse_time_t(&Config.digest.rebuild_period);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'digest_rebuild_period' requires --enable-cache-digests");
#endif
        return 1;
    };
    if (!strcmp(token, "digest_rewrite_period")) {
#if USE_CACHE_DIGESTS
        parse_time_t(&Config.digest.rewrite_period);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'digest_rewrite_period' requires --enable-cache-digests");
#endif
        return 1;
    };
    if (!strcmp(token, "digest_swapout_chunk_size")) {
#if USE_CACHE_DIGESTS
        parse_b_size_t(&Config.digest.swapout_chunk_size);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'digest_swapout_chunk_size' requires --enable-cache-digests");
#endif
        return 1;
    };
    if (!strcmp(token, "digest_rebuild_chunk_percentage")) {
#if USE_CACHE_DIGESTS
        parse_int(&Config.digest.rebuild_chunk_percentage);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'digest_rebuild_chunk_percentage' requires --enable-cache-digests");
#endif
        return 1;
    };
    if (!strcmp(token, "snmp_port")) {
#if SQUID_SNMP
        parse_u_short(&Config.Port.snmp);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'snmp_port' requires --enable-snmp");
#endif
        return 1;
    };
    if (!strcmp(token, "snmp_access")) {
#if SQUID_SNMP
        parse_acl_access(&Config.accessList.snmp);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'snmp_access' requires --enable-snmp");
#endif
        return 1;
    };
    if (!strcmp(token, "snmp_incoming_address")) {
#if SQUID_SNMP
        parse_address(&Config.Addrs.snmp_incoming);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'snmp_incoming_address' requires --enable-snmp");
#endif
        return 1;
    };
    if (!strcmp(token, "snmp_outgoing_address")) {
#if SQUID_SNMP
        parse_address(&Config.Addrs.snmp_outgoing);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'snmp_outgoing_address' requires --enable-snmp");
#endif
        return 1;
    };
    if (!strcmp(token, "icp_port")) {
        parse_u_short(&Config.Port.icp);
        return 1;
    };
    if (!strcmp(token, "udp_port")) {
        parse_u_short(&Config.Port.icp);
        return 1;
    };
    if (!strcmp(token, "htcp_port")) {
#if USE_HTCP
        parse_u_short(&Config.Port.htcp);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'htcp_port' requires --enable-htcp");
#endif
        return 1;
    };
    if (!strcmp(token, "log_icp_queries")) {
        parse_onoff(&Config.onoff.log_udp);
        return 1;
    };
    if (!strcmp(token, "udp_incoming_address")) {
        parse_address(&Config.Addrs.udp_incoming);
        return 1;
    };
    if (!strcmp(token, "udp_outgoing_address")) {
        parse_address(&Config.Addrs.udp_outgoing);
        return 1;
    };
    if (!strcmp(token, "icp_hit_stale")) {
        parse_onoff(&Config.onoff.icp_hit_stale);
        return 1;
    };
    if (!strcmp(token, "minimum_direct_hops")) {
        parse_int(&Config.minDirectHops);
        return 1;
    };
    if (!strcmp(token, "minimum_direct_rtt")) {
        parse_int(&Config.minDirectRtt);
        return 1;
    };
    if (!strcmp(token, "netdb_low")) {
        parse_int(&Config.Netdb.low);
        return 1;
    };
    if (!strcmp(token, "netdb_high")) {
        parse_int(&Config.Netdb.high);
        return 1;
    };
    if (!strcmp(token, "netdb_ping_period")) {
        parse_time_t(&Config.Netdb.period);
        return 1;
    };
    if (!strcmp(token, "query_icmp")) {
        parse_onoff(&Config.onoff.query_icmp);
        return 1;
    };
    if (!strcmp(token, "test_reachability")) {
        parse_onoff(&Config.onoff.test_reachability);
        return 1;
    };
    if (!strcmp(token, "icp_query_timeout")) {
        parse_int(&Config.Timeout.icp_query);
        return 1;
    };
    if (!strcmp(token, "maximum_icp_query_timeout")) {
        parse_int(&Config.Timeout.icp_query_max);
        return 1;
    };
    if (!strcmp(token, "minimum_icp_query_timeout")) {
        parse_int(&Config.Timeout.icp_query_min);
        return 1;
    };
    if (!strcmp(token, "background_ping_rate")) {
        parse_time_t(&Config.backgroundPingRate);
        return 1;
    };
    if (!strcmp(token, "mcast_groups")) {
        parse_wordlist(&Config.mcast_group_list);
        return 1;
    };
    if (!strcmp(token, "mcast_miss_addr")) {
#if MULTICAST_MISS_STREAM
        parse_address(&Config.mcast_miss.addr);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'mcast_miss_addr' requires -DMULTICAST_MISS_STREAM define");
#endif
        return 1;
    };
    if (!strcmp(token, "mcast_miss_ttl")) {
#if MULTICAST_MISS_STREAM
        parse_u_short(&Config.mcast_miss.ttl);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'mcast_miss_ttl' requires -DMULTICAST_MISS_STREAM define");
#endif
        return 1;
    };
    if (!strcmp(token, "mcast_miss_port")) {
#if MULTICAST_MISS_STREAM
        parse_u_short(&Config.mcast_miss.port);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'mcast_miss_port' requires -DMULTICAST_MISS_STREAM define");
#endif
        return 1;
    };
    if (!strcmp(token, "mcast_miss_encode_key")) {
#if MULTICAST_MISS_STREAM
        parse_string(&Config.mcast_miss.encode_key);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'mcast_miss_encode_key' requires -DMULTICAST_MISS_STREAM define");
#endif
        return 1;
    };
    if (!strcmp(token, "mcast_icp_query_timeout")) {
        parse_int(&Config.Timeout.mcast_icp_query);
        return 1;
    };
    if (!strcmp(token, "icon_directory")) {
        parse_string(&Config.icons.directory);
        return 1;
    };
    if (!strcmp(token, "global_internal_static")) {
        parse_onoff(&Config.onoff.global_internal_static);
        return 1;
    };
    if (!strcmp(token, "short_icon_urls")) {
        parse_onoff(&Config.icons.use_short_names);
        return 1;
    };
    if (!strcmp(token, "error_directory")) {
        parse_string(&Config.errorDirectory);
        return 1;
    };
    if (!strcmp(token, "error_default_language")) {
#if USE_ERR_LOCALES
        parse_string(&Config.errorDefaultLanguage);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'error_default_language' requires --enable-auto-locale");
#endif
        return 1;
    };
    if (!strcmp(token, "error_log_languages")) {
#if USE_ERR_LOCALES
        parse_onoff(&Config.errorLogMissingLanguages);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'error_log_languages' requires --enable-auto-locale");
#endif
        return 1;
    };
    if (!strcmp(token, "err_page_stylesheet")) {
        parse_string(&Config.errorStylesheet);
        return 1;
    };
    if (!strcmp(token, "err_html_text")) {
        parse_eol(&Config.errHtmlText);
        return 1;
    };
    if (!strcmp(token, "email_err_data")) {
        parse_onoff(&Config.onoff.emailErrData);
        return 1;
    };
    if (!strcmp(token, "deny_info")) {
        parse_denyinfo(&Config.denyInfoList);
        return 1;
    };
    if (!strcmp(token, "nonhierarchical_direct")) {
        parse_onoff(&Config.onoff.nonhierarchical_direct);
        return 1;
    };
    if (!strcmp(token, "prefer_direct")) {
        parse_onoff(&Config.onoff.prefer_direct);
        return 1;
    };
    if (!strcmp(token, "always_direct")) {
        parse_acl_access(&Config.accessList.AlwaysDirect);
        return 1;
    };
    if (!strcmp(token, "never_direct")) {
        parse_acl_access(&Config.accessList.NeverDirect);
        return 1;
    };
    if (!strcmp(token, "incoming_udp_average")) {
        parse_int(&Config.comm_incoming.udp.average);
        return 1;
    };
    if (!strcmp(token, "incoming_icp_average")) {
        parse_int(&Config.comm_incoming.udp.average);
        return 1;
    };
    if (!strcmp(token, "incoming_tcp_average")) {
        parse_int(&Config.comm_incoming.tcp.average);
        return 1;
    };
    if (!strcmp(token, "incoming_http_average")) {
        parse_int(&Config.comm_incoming.tcp.average);
        return 1;
    };
    if (!strcmp(token, "incoming_dns_average")) {
        parse_int(&Config.comm_incoming.dns.average);
        return 1;
    };
    if (!strcmp(token, "min_udp_poll_cnt")) {
        parse_int(&Config.comm_incoming.udp.min_poll);
        return 1;
    };
    if (!strcmp(token, "min_icp_poll_cnt")) {
        parse_int(&Config.comm_incoming.udp.min_poll);
        return 1;
    };
    if (!strcmp(token, "min_dns_poll_cnt")) {
        parse_int(&Config.comm_incoming.dns.min_poll);
        return 1;
    };
    if (!strcmp(token, "min_tcp_poll_cnt")) {
        parse_int(&Config.comm_incoming.tcp.min_poll);
        return 1;
    };
    if (!strcmp(token, "min_http_poll_cnt")) {
        parse_int(&Config.comm_incoming.tcp.min_poll);
        return 1;
    };
    if (!strcmp(token, "accept_filter")) {
        parse_string(&Config.accept_filter);
        return 1;
    };
    if (!strcmp(token, "client_ip_max_connections")) {
        parse_int(&Config.client_ip_max_connections);
        return 1;
    };
    if (!strcmp(token, "tcp_recv_bufsize")) {
        parse_b_size_t(&Config.tcpRcvBufsz);
        return 1;
    };
    if (!strcmp(token, "icap_enable")) {
#if ICAP_CLIENT
        parse_onoff(&Adaptation::Icap::TheConfig.onoff);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'icap_enable' requires --enable-icap-client");
#endif
        return 1;
    };
    if (!strcmp(token, "icap_connect_timeout")) {
#if ICAP_CLIENT
        parse_time_t(&Adaptation::Icap::TheConfig.connect_timeout_raw);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'icap_connect_timeout' requires --enable-icap-client");
#endif
        return 1;
    };
    if (!strcmp(token, "icap_io_timeout")) {
#if ICAP_CLIENT
        parse_time_t(&Adaptation::Icap::TheConfig.io_timeout_raw);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'icap_io_timeout' requires --enable-icap-client");
#endif
        return 1;
    };
    if (!strcmp(token, "icap_service_failure_limit")) {
#if ICAP_CLIENT
        parse_icap_service_failure_limit(&Adaptation::Icap::TheConfig);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'icap_service_failure_limit' requires --enable-icap-client");
#endif
        return 1;
    };
    if (!strcmp(token, "icap_service_revival_delay")) {
#if ICAP_CLIENT
        parse_int(&Adaptation::Icap::TheConfig.service_revival_delay);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'icap_service_revival_delay' requires --enable-icap-client");
#endif
        return 1;
    };
    if (!strcmp(token, "icap_preview_enable")) {
#if ICAP_CLIENT
        parse_onoff(&Adaptation::Icap::TheConfig.preview_enable);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'icap_preview_enable' requires --enable-icap-client");
#endif
        return 1;
    };
    if (!strcmp(token, "icap_preview_size")) {
#if ICAP_CLIENT
        parse_int(&Adaptation::Icap::TheConfig.preview_size);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'icap_preview_size' requires --enable-icap-client");
#endif
        return 1;
    };
    if (!strcmp(token, "icap_206_enable")) {
#if ICAP_CLIENT
        parse_onoff(&Adaptation::Icap::TheConfig.allow206_enable);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'icap_206_enable' requires --enable-icap-client");
#endif
        return 1;
    };
    if (!strcmp(token, "icap_default_options_ttl")) {
#if ICAP_CLIENT
        parse_int(&Adaptation::Icap::TheConfig.default_options_ttl);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'icap_default_options_ttl' requires --enable-icap-client");
#endif
        return 1;
    };
    if (!strcmp(token, "icap_persistent_connections")) {
#if ICAP_CLIENT
        parse_onoff(&Adaptation::Icap::TheConfig.reuse_connections);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'icap_persistent_connections' requires --enable-icap-client");
#endif
        return 1;
    };
    if (!strcmp(token, "adaptation_send_client_ip")) {
#if USE_ADAPTATION
        parse_onoff(&Adaptation::Config::send_client_ip);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'adaptation_send_client_ip' requires --enable-ecap or --enable-icap-client");
#endif
        return 1;
    };
    if (!strcmp(token, "icap_send_client_ip")) {
#if USE_ADAPTATION
        parse_onoff(&Adaptation::Config::send_client_ip);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'adaptation_send_client_ip' requires --enable-ecap or --enable-icap-client");
#endif
        return 1;
    };
    if (!strcmp(token, "adaptation_send_username")) {
#if USE_ADAPTATION
        parse_onoff(&Adaptation::Config::send_username);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'adaptation_send_username' requires --enable-ecap or --enable-icap-client");
#endif
        return 1;
    };
    if (!strcmp(token, "icap_send_client_username")) {
#if USE_ADAPTATION
        parse_onoff(&Adaptation::Config::send_username);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'adaptation_send_username' requires --enable-ecap or --enable-icap-client");
#endif
        return 1;
    };
    if (!strcmp(token, "icap_client_username_header")) {
#if ICAP_CLIENT
        parse_string(&Adaptation::Icap::TheConfig.client_username_header);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'icap_client_username_header' requires --enable-icap-client");
#endif
        return 1;
    };
    if (!strcmp(token, "icap_client_username_encode")) {
#if ICAP_CLIENT
        parse_onoff(&Adaptation::Icap::TheConfig.client_username_encode);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'icap_client_username_encode' requires --enable-icap-client");
#endif
        return 1;
    };
    if (!strcmp(token, "icap_service")) {
#if ICAP_CLIENT
        parse_icap_service_type(&Adaptation::Icap::TheConfig);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'icap_service' requires --enable-icap-client");
#endif
        return 1;
    };
    if (!strcmp(token, "icap_class")) {
#if ICAP_CLIENT
        parse_icap_class_type();
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'icap_class' requires --enable-icap-client");
#endif
        return 1;
    };
    if (!strcmp(token, "icap_access")) {
#if ICAP_CLIENT
        parse_icap_access_type();
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'icap_access' requires --enable-icap-client");
#endif
        return 1;
    };
    if (!strcmp(token, "ecap_enable")) {
#if USE_ECAP
        parse_onoff(&Adaptation::Ecap::TheConfig.onoff);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'ecap_enable' requires --enable-ecap");
#endif
        return 1;
    };
    if (!strcmp(token, "ecap_service")) {
#if USE_ECAP
        parse_ecap_service_type(&Adaptation::Ecap::TheConfig);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'ecap_service' requires --enable-ecap");
#endif
        return 1;
    };
    if (!strcmp(token, "loadable_modules")) {
#if USE_LOADABLE_MODULES
        parse_wordlist(&Config.loadable_module_names);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'loadable_modules' requires --enable-loadable-modules");
#endif
        return 1;
    };
    if (!strcmp(token, "adaptation_service_set")) {
#if USE_ADAPTATION
        parse_adaptation_service_set_type();
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'adaptation_service_set' requires --enable-ecap or --enable-icap-client");
#endif
        return 1;
    };
    if (!strcmp(token, "adaptation_service_chain")) {
#if USE_ADAPTATION
        parse_adaptation_service_chain_type();
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'adaptation_service_chain' requires --enable-ecap or --enable-icap-client");
#endif
        return 1;
    };
    if (!strcmp(token, "adaptation_access")) {
#if USE_ADAPTATION
        parse_adaptation_access_type();
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'adaptation_access' requires --enable-ecap or --enable-icap-client");
#endif
        return 1;
    };
    if (!strcmp(token, "adaptation_service_iteration_limit")) {
#if USE_ADAPTATION
        parse_int(&Adaptation::Config::service_iteration_limit);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'adaptation_service_iteration_limit' requires --enable-ecap or --enable-icap-client");
#endif
        return 1;
    };
    if (!strcmp(token, "adaptation_masterx_shared_names")) {
#if USE_ADAPTATION
        parse_string(&Adaptation::Config::masterx_shared_name);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'adaptation_masterx_shared_names' requires --enable-ecap or --enable-icap-client");
#endif
        return 1;
    };
    if (!strcmp(token, "adaptation_meta")) {
#if USE_ADAPTATION
        parse_adaptation_meta_type(&Adaptation::Config::metaHeaders);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'adaptation_meta' requires --enable-ecap or --enable-icap-client");
#endif
        return 1;
    };
    if (!strcmp(token, "icap_retry")) {
#if ICAP_CLIENT
        parse_acl_access(&Adaptation::Icap::TheConfig.repeat);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'icap_retry' requires --enable-icap-client");
#endif
        return 1;
    };
    if (!strcmp(token, "icap_retry_limit")) {
#if ICAP_CLIENT
        parse_int(&Adaptation::Icap::TheConfig.repeat_limit);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'icap_retry_limit' requires --enable-icap-client");
#endif
        return 1;
    };
    if (!strcmp(token, "check_hostnames")) {
        parse_onoff(&Config.onoff.check_hostnames);
        return 1;
    };
    if (!strcmp(token, "allow_underscore")) {
        parse_onoff(&Config.onoff.allow_underscore);
        return 1;
    };
    if (!strcmp(token, "cache_dns_program")) {
#if USE_DNSHELPER
        parse_string(&Config.Program.dnsserver);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'cache_dns_program' requires --disable-internal-dns");
#endif
        return 1;
    };
    if (!strcmp(token, "dns_children")) {
#if USE_DNSHELPER
        parse_HelperChildConfig(&Config.dnsChildren);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'dns_children' requires --disable-internal-dns");
#endif
        return 1;
    };
    if (!strcmp(token, "dns_retransmit_interval")) {
#if !USE_DNSHELPER
        parse_time_msec(&Config.Timeout.idns_retransmit);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'dns_retransmit_interval' requires --enable-internal-dns");
#endif
        return 1;
    };
    if (!strcmp(token, "dns_timeout")) {
#if !USE_DNSHELPER
        parse_time_msec(&Config.Timeout.idns_query);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'dns_timeout' requires --enable-internal-dns");
#endif
        return 1;
    };
    if (!strcmp(token, "dns_packet_max")) {
#if !USE_DNSHELPER
        parse_b_ssize_t(&Config.dns.packet_max);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'dns_packet_max' requires --enable-internal-dns");
#endif
        return 1;
    };
    if (!strcmp(token, "dns_defnames")) {
        parse_onoff(&Config.onoff.res_defnames);
        return 1;
    };
    if (!strcmp(token, "dns_nameservers")) {
        parse_wordlist(&Config.dns_nameservers);
        return 1;
    };
    if (!strcmp(token, "hosts_file")) {
        parse_string(&Config.etcHostsPath);
        return 1;
    };
    if (!strcmp(token, "append_domain")) {
        parse_string(&Config.appendDomain);
        return 1;
    };
    if (!strcmp(token, "ignore_unknown_nameservers")) {
#if !USE_DNSHELPER
        parse_onoff(&Config.onoff.ignore_unknown_nameservers);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'ignore_unknown_nameservers' requires --enable-internal-dns");
#endif
        return 1;
    };
    if (!strcmp(token, "dns_v4_first")) {
#if !USE_DNSHELPER
        parse_onoff(&Config.dns.v4_first);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'dns_v4_first' requires --enable-internal-dns");
#endif
        return 1;
    };
    if (!strcmp(token, "ipcache_size")) {
        parse_int(&Config.ipcache.size);
        return 1;
    };
    if (!strcmp(token, "ipcache_low")) {
        parse_int(&Config.ipcache.low);
        return 1;
    };
    if (!strcmp(token, "ipcache_high")) {
        parse_int(&Config.ipcache.high);
        return 1;
    };
    if (!strcmp(token, "fqdncache_size")) {
        parse_int(&Config.fqdncache.size);
        return 1;
    };
    if (!strcmp(token, "memory_pools")) {
        parse_onoff(&Config.onoff.mem_pools);
        return 1;
    };
    if (!strcmp(token, "memory_pools_limit")) {
        parse_b_int64_t(&Config.MemPools.limit);
        return 1;
    };
    if (!strcmp(token, "forwarded_for")) {
        parse_string(&opt_forwarded_for);
        return 1;
    };
    if (!strcmp(token, "cachemgr_passwd")) {
        parse_cachemgrpasswd(&Config.passwd_list);
        return 1;
    };
    if (!strcmp(token, "client_db")) {
        parse_onoff(&Config.onoff.client_db);
        return 1;
    };
    if (!strcmp(token, "refresh_all_ims")) {
        parse_onoff(&Config.onoff.refresh_all_ims);
        return 1;
    };
    if (!strcmp(token, "reload_into_ims")) {
#if USE_HTTP_VIOLATIONS
        parse_onoff(&Config.onoff.reload_into_ims);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'reload_into_ims' requires --enable-http-violations");
#endif
        return 1;
    };
    if (!strcmp(token, "connect_retries")) {
        parse_int(&Config.connect_retries);
        return 1;
    };
    if (!strcmp(token, "retry_on_error")) {
        parse_onoff(&Config.retry.onerror);
        return 1;
    };
    if (!strcmp(token, "as_whois_server")) {
        parse_string(&Config.as_whois_server);
        return 1;
    };
    if (!strcmp(token, "offline_mode")) {
        parse_onoff(&Config.onoff.offline);
        return 1;
    };
    if (!strcmp(token, "uri_whitespace")) {
        parse_uri_whitespace(&Config.uri_whitespace);
        return 1;
    };
    if (!strcmp(token, "chroot")) {
        parse_string(&Config.chroot_dir);
        return 1;
    };
    if (!strcmp(token, "balance_on_multiple_ip")) {
        parse_onoff(&Config.onoff.balance_on_multiple_ip);
        return 1;
    };
    if (!strcmp(token, "pipeline_prefetch")) {
        parse_onoff(&Config.onoff.pipeline_prefetch);
        return 1;
    };
    if (!strcmp(token, "high_response_time_warning")) {
        parse_int(&Config.warnings.high_rptm);
        return 1;
    };
    if (!strcmp(token, "high_page_fault_warning")) {
        parse_int(&Config.warnings.high_pf);
        return 1;
    };
    if (!strcmp(token, "high_memory_warning")) {
        parse_b_size_t(&Config.warnings.high_memory);
        return 1;
    };
    if (!strcmp(token, "sleep_after_fork")) {
        parse_int(&Config.sleep_after_fork);
        return 1;
    };
    if (!strcmp(token, "windows_ipaddrchangemonitor")) {
#if _SQUID_MSWIN_
        parse_onoff(&Config.onoff.WIN32_IpAddrChangeMonitor);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'windows_ipaddrchangemonitor' requires MS Windows");
#endif
        return 1;
    };
    if (!strcmp(token, "eui_lookup")) {
#if USE_SQUID_EUI
        parse_onoff(&Eui::TheConfig.euiLookup);
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'eui_lookup' requires --enable-eui");
#endif
        return 1;
    };
    if (!strcmp(token, "max_filedescriptors")) {
        parse_int(&Config.max_filedescriptors);
        return 1;
    };
    if (!strcmp(token, "max_filedesc")) {
        parse_int(&Config.max_filedescriptors);
        return 1;
    };
    if (!strcmp(token, "workers")) {
        parse_int(&Config.workers);
        return 1;
    };
    if (!strcmp(token, "cpu_affinity_map")) {
        parse_CpuAffinityMap(&Config.cpuAffinityMap);
        return 1;
    };
	return 0; /* failure */
}

static void
dump_config(StoreEntry *entry)
{
    debugs(5, 4, HERE);
#if USE_AUTH
    dump_authparam(entry, "auth_param", Auth::TheConfig);
#endif
    dump_time_t(entry, "authenticate_cache_garbage_interval", Config.authenticateGCInterval);
    dump_time_t(entry, "authenticate_ttl", Config.authenticateTTL);
    dump_time_t(entry, "authenticate_ip_ttl", Config.authenticateIpTTL);
    dump_externalAclHelper(entry, "external_acl_type", Config.externalAclHelperList);
    dump_acl(entry, "acl", Config.aclList);
#if FOLLOW_X_FORWARDED_FOR
    dump_acl_access(entry, "follow_x_forwarded_for", Config.accessList.followXFF);
#endif
#if FOLLOW_X_FORWARDED_FOR
    dump_onoff(entry, "acl_uses_indirect_client", Config.onoff.acl_uses_indirect_client);
#endif
#if FOLLOW_X_FORWARDED_FOR&&USE_DELAY_POOLS
    dump_onoff(entry, "delay_pool_uses_indirect_client", Config.onoff.delay_pool_uses_indirect_client);
#endif
#if FOLLOW_X_FORWARDED_FOR
    dump_onoff(entry, "log_uses_indirect_client", Config.onoff.log_uses_indirect_client);
#endif
#if FOLLOW_X_FORWARDED_FOR&&LINUX_NETFILTER
    dump_onoff(entry, "tproxy_uses_indirect_client", Config.onoff.tproxy_uses_indirect_client);
#endif
    dump_acl_access(entry, "http_access", Config.accessList.http);
    dump_acl_access(entry, "adapted_http_access", Config.accessList.adapted_http);
    dump_acl_access(entry, "http_reply_access", Config.accessList.reply);
    dump_acl_access(entry, "icp_access", Config.accessList.icp);
#if USE_HTCP
    dump_acl_access(entry, "htcp_access", Config.accessList.htcp);
#endif
#if USE_HTCP
    dump_acl_access(entry, "htcp_clr_access", Config.accessList.htcp_clr);
#endif
    dump_acl_access(entry, "miss_access", Config.accessList.miss);
#if USE_IDENT
    dump_acl_access(entry, "ident_lookup_access", Ident::TheConfig.identLookup);
#endif
    dump_acl_b_size_t(entry, "reply_body_max_size", Config.ReplyBodySize);
    dump_PortCfg(entry, "http_port", Config.Sockaddr.http);
#if USE_SSL
    dump_PortCfg(entry, "https_port", Config.Sockaddr.https);
#endif
    dump_acl_tos(entry, "tcp_outgoing_tos", Ip::Qos::TheConfig.tosToServer);
    dump_acl_tos(entry, "clientside_tos", Ip::Qos::TheConfig.tosToClient);
#if SO_MARK&&USE_LIBCAP
    dump_acl_nfmark(entry, "tcp_outgoing_mark", Ip::Qos::TheConfig.nfmarkToServer);
#endif
#if SO_MARK&&USE_LIBCAP
    dump_acl_nfmark(entry, "clientside_mark", Ip::Qos::TheConfig.nfmarkToClient);
#endif
#if USE_QOS_TOS
    dump_QosConfig(entry, "qos_flows", Ip::Qos::TheConfig);
#endif
    dump_acl_address(entry, "tcp_outgoing_address", Config.accessList.outgoing_address);
    dump_onoff(entry, "host_verify_strict", Config.onoff.hostStrictVerify);
    dump_onoff(entry, "client_dst_passthru", Config.onoff.client_dst_passthru);
#if USE_SSL
    dump_onoff(entry, "ssl_unclean_shutdown", Config.SSL.unclean_shutdown);
#endif
#if USE_SSL
    dump_string(entry, "ssl_engine", Config.SSL.ssl_engine);
#endif
#if USE_SSL
    dump_string(entry, "sslproxy_client_certificate", Config.ssl_client.cert);
#endif
#if USE_SSL
    dump_string(entry, "sslproxy_client_key", Config.ssl_client.key);
#endif
#if USE_SSL
    dump_int(entry, "sslproxy_version", Config.ssl_client.version);
#endif
#if USE_SSL
    dump_string(entry, "sslproxy_options", Config.ssl_client.options);
#endif
#if USE_SSL
    dump_string(entry, "sslproxy_cipher", Config.ssl_client.cipher);
#endif
#if USE_SSL
    dump_string(entry, "sslproxy_cafile", Config.ssl_client.cafile);
#endif
#if USE_SSL
    dump_string(entry, "sslproxy_capath", Config.ssl_client.capath);
#endif
#if USE_SSL
    dump_sslproxy_ssl_bump(entry, "ssl_bump", Config.accessList.ssl_bump);
#endif
#if USE_SSL
    dump_string(entry, "sslproxy_flags", Config.ssl_client.flags);
#endif
#if USE_SSL
    dump_acl_access(entry, "sslproxy_cert_error", Config.ssl_client.cert_error);
#endif
#if USE_SSL
    dump_sslproxy_cert_sign(entry, "sslproxy_cert_sign", Config.ssl_client.cert_sign);
#endif
#if USE_SSL
    dump_sslproxy_cert_adapt(entry, "sslproxy_cert_adapt", Config.ssl_client.cert_adapt);
#endif
#if USE_SSL
    dump_string(entry, "sslpassword_program", Config.Program.ssl_password);
#endif
#if USE_SSL_CRTD
    dump_eol(entry, "sslcrtd_program", Ssl::TheConfig.ssl_crtd);
#endif
#if USE_SSL_CRTD
    dump_HelperChildConfig(entry, "sslcrtd_children", Ssl::TheConfig.ssl_crtdChildren);
#endif
    dump_peer(entry, "cache_peer", Config.peers);
    dump_time_t(entry, "dead_peer_timeout", Config.Timeout.deadPeer);
    dump_int(entry, "forward_max_tries", Config.forward_max_tries);
    dump_wordlist(entry, "hierarchy_stoplist", Config.hierarchy_stoplist);
    dump_b_size_t(entry, "cache_mem", Config.memMaxSize);
    dump_b_size_t(entry, "maximum_object_size_in_memory", Config.Store.maxInMemObjSize);
    dump_YesNoNone(entry, "memory_cache_shared", Config.memShared);
    dump_memcachemode(entry, "memory_cache_mode", Config);
    dump_removalpolicy(entry, "memory_replacement_policy", Config.memPolicy);
    dump_removalpolicy(entry, "cache_replacement_policy", Config.replPolicy);
    dump_cachedir(entry, "cache_dir", Config.cacheSwap);
    dump_string(entry, "store_dir_select_algorithm", Config.store_dir_select_algorithm);
    dump_int(entry, "max_open_disk_fds", Config.max_open_disk_fds);
    dump_b_int64_t(entry, "minimum_object_size", Config.Store.minObjectSize);
    dump_b_int64_t(entry, "maximum_object_size", Config.Store.maxObjectSize);
    dump_int(entry, "cache_swap_low", Config.Swap.lowWaterMark);
    dump_int(entry, "cache_swap_high", Config.Swap.highWaterMark);
    dump_logformat(entry, "logformat", Log::TheConfig);
    dump_access_log(entry, "access_log", Config.Log.accesslogs);
#if ICAP_CLIENT
    dump_access_log(entry, "icap_log", Config.Log.icaplogs);
#endif
    dump_string(entry, "logfile_daemon", Log::TheConfig.logfile_daemon);
    dump_acl_access(entry, "log_access", Config.accessList.log);
#if ICAP_CLIENT
    dump_acl_access(entry, "log_icap", Config.accessList.icap);
#endif
    dump_string(entry, "cache_store_log", Config.Log.store);
    dump_string(entry, "cache_swap_state", Config.Log.swap);
    dump_int(entry, "logfile_rotate", Config.Log.rotateNumber);
    dump_string(entry, "mime_table", Config.mimeTablePathname);
    dump_onoff(entry, "log_mime_hdrs", Config.onoff.log_mime_hdrs);
    dump_string(entry, "pid_filename", Config.pidFilename);
    dump_address(entry, "client_netmask", Config.Addrs.client_netmask);
    dump_onoff(entry, "strip_query_terms", Config.onoff.strip_query_terms);
    dump_onoff(entry, "buffered_logs", Config.onoff.buffered_logs);
#if USE_ICMP
    dump_string(entry, "netdb_filename", Config.netdbFilename);
#endif
    dump_string(entry, "cache_log", Debug::cache_log);
    dump_eol(entry, "debug_options", Debug::debugOptions);
    dump_string(entry, "coredump_dir", Config.coredump_dir);
    dump_string(entry, "ftp_user", Config.Ftp.anon_user);
    dump_onoff(entry, "ftp_passive", Config.Ftp.passive);
    dump_onoff(entry, "ftp_epsv_all", Config.Ftp.epsv_all);
    dump_onoff(entry, "ftp_epsv", Config.Ftp.epsv);
    dump_onoff(entry, "ftp_eprt", Config.Ftp.eprt);
    dump_onoff(entry, "ftp_sanitycheck", Config.Ftp.sanitycheck);
    dump_onoff(entry, "ftp_telnet_protocol", Config.Ftp.telnet);
    dump_string(entry, "diskd_program", Config.Program.diskd);
#if USE_UNLINKD
    dump_string(entry, "unlinkd_program", Config.Program.unlinkd);
#endif
#if USE_ICMP
    dump_string(entry, "pinger_program", Config.pinger.program);
#endif
#if USE_ICMP
    dump_onoff(entry, "pinger_enable", Config.pinger.enable);
#endif
    dump_wordlist(entry, "url_rewrite_program", Config.Program.redirect);
    dump_HelperChildConfig(entry, "url_rewrite_children", Config.redirectChildren);
    dump_onoff(entry, "url_rewrite_host_header", Config.onoff.redir_rewrites_host);
    dump_acl_access(entry, "url_rewrite_access", Config.accessList.redirector);
    dump_onoff(entry, "url_rewrite_bypass", Config.onoff.redirector_bypass);
    dump_acl_access(entry, "cache", Config.accessList.noCache);
    dump_time_t(entry, "max_stale", Config.maxStale);
    dump_refreshpattern(entry, "refresh_pattern", Config.Refresh);
    dump_kb_int64_t(entry, "quick_abort_min", Config.quickAbort.min);
    dump_kb_int64_t(entry, "quick_abort_max", Config.quickAbort.max);
    dump_int(entry, "quick_abort_pct", Config.quickAbort.pct);
    dump_b_int64_t(entry, "read_ahead_gap", Config.readAheadGap);
#if USE_HTTP_VIOLATIONS
    dump_time_t(entry, "negative_ttl", Config.negativeTtl);
#endif
    dump_time_t(entry, "positive_dns_ttl", Config.positiveDnsTtl);
    dump_time_t(entry, "negative_dns_ttl", Config.negativeDnsTtl);
    dump_acl_b_size_t(entry, "range_offset_limit", Config.rangeOffsetLimit);
    dump_time_t(entry, "minimum_expiry_time", Config.minimum_expiry_time);
    dump_b_int64_t(entry, "store_avg_object_size", Config.Store.avgObjectSize);
    dump_int(entry, "store_objects_per_bucket", Config.Store.objectsPerBucket);
    dump_b_size_t(entry, "request_header_max_size", Config.maxRequestHeaderSize);
    dump_b_size_t(entry, "reply_header_max_size", Config.maxReplyHeaderSize);
    dump_b_int64_t(entry, "request_body_max_size", Config.maxRequestBodySize);
    dump_b_size_t(entry, "client_request_buffer_max_size", Config.maxRequestBufferSize);
    dump_b_int64_t(entry, "chunked_request_body_max_size", Config.maxChunkedRequestBodySize);
#if USE_HTTP_VIOLATIONS
    dump_acl_access(entry, "broken_posts", Config.accessList.brokenPosts);
#endif
#if FOLLOW_X_FORWARDED_FOR&&USE_ADAPTATION
    dump_onoff(entry, "adaptation_uses_indirect_client", Adaptation::Config::use_indirect_client);
#endif
#if USE_HTTP_VIOLATIONS
    dump_onoff(entry, "via", Config.onoff.via);
#endif
    dump_onoff(entry, "ie_refresh", Config.onoff.ie_refresh);
    dump_onoff(entry, "vary_ignore_expire", Config.onoff.vary_ignore_expire);
    dump_onoff(entry, "request_entities", Config.onoff.request_entities);
#if USE_HTTP_VIOLATIONS
    dump_http_header_access(entry, "request_header_access", Config.request_header_access);
#endif
#if USE_HTTP_VIOLATIONS
    dump_http_header_access(entry, "reply_header_access", Config.reply_header_access);
#endif
#if USE_HTTP_VIOLATIONS
    dump_http_header_replace(entry, "request_header_replace", Config.request_header_access);
#endif
#if USE_HTTP_VIOLATIONS
    dump_http_header_replace(entry, "reply_header_replace", Config.reply_header_access);
#endif
    dump_HeaderWithAclList(entry, "request_header_add", Config.request_header_add);
    dump_tristate(entry, "relaxed_header_parser", Config.onoff.relaxed_header_parser);
    dump_time_t(entry, "forward_timeout", Config.Timeout.forward);
    dump_time_t(entry, "connect_timeout", Config.Timeout.connect);
    dump_time_t(entry, "peer_connect_timeout", Config.Timeout.peer_connect);
    dump_time_t(entry, "read_timeout", Config.Timeout.read);
    dump_time_t(entry, "write_timeout", Config.Timeout.write);
    dump_time_t(entry, "request_timeout", Config.Timeout.request);
    dump_time_t(entry, "client_idle_pconn_timeout", Config.Timeout.clientIdlePconn);
    dump_time_t(entry, "client_lifetime", Config.Timeout.lifetime);
    dump_onoff(entry, "half_closed_clients", Config.onoff.half_closed_clients);
    dump_time_t(entry, "server_idle_pconn_timeout", Config.Timeout.serverIdlePconn);
#if USE_IDENT
    dump_time_t(entry, "ident_timeout", Ident::TheConfig.timeout);
#endif
    dump_time_t(entry, "shutdown_lifetime", Config.shutdownLifetime);
    dump_string(entry, "cache_mgr", Config.adminEmail);
    dump_string(entry, "mail_from", Config.EmailFrom);
    dump_eol(entry, "mail_program", Config.EmailProgram);
    dump_string(entry, "cache_effective_user", Config.effectiveUser);
    dump_string(entry, "cache_effective_group", Config.effectiveGroup);
    dump_onoff(entry, "httpd_suppress_version_string", Config.onoff.httpd_suppress_version_string);
    dump_string(entry, "visible_hostname", Config.visibleHostname);
    dump_string(entry, "unique_hostname", Config.uniqueHostname);
    dump_wordlist(entry, "hostname_aliases", Config.hostnameAliases);
    dump_int(entry, "umask", Config.umask);
    dump_time_t(entry, "announce_period", Config.Announce.period);
    dump_string(entry, "announce_host", Config.Announce.host);
    dump_string(entry, "announce_file", Config.Announce.file);
    dump_u_short(entry, "announce_port", Config.Announce.port);
    dump_string(entry, "httpd_accel_surrogate_id", Config.Accel.surrogate_id);
    dump_onoff(entry, "http_accel_surrogate_remote", Config.onoff.surrogate_is_remote);
#if USE_SQUID_ESI
    dump_string(entry, "esi_parser", ESIParser::Type);
#endif
#if USE_DELAY_POOLS
    dump_delay_pool_count(entry, "delay_pools", Config.Delay);
#endif
#if USE_DELAY_POOLS
    dump_delay_pool_class(entry, "delay_class", Config.Delay);
#endif
#if USE_DELAY_POOLS
    dump_delay_pool_access(entry, "delay_access", Config.Delay);
#endif
#if USE_DELAY_POOLS
    dump_delay_pool_rates(entry, "delay_parameters", Config.Delay);
#endif
#if USE_DELAY_POOLS
    dump_u_short(entry, "delay_initial_bucket_level", Config.Delay.initial);
#endif
#if USE_DELAY_POOLS
    dump_client_delay_pool_count(entry, "client_delay_pools", Config.ClientDelay);
#endif
#if USE_DELAY_POOLS
    dump_u_short(entry, "client_delay_initial_bucket_level", Config.ClientDelay.initial);
#endif
#if USE_DELAY_POOLS
    dump_client_delay_pool_rates(entry, "client_delay_parameters", Config.ClientDelay);
#endif
#if USE_DELAY_POOLS
    dump_client_delay_pool_access(entry, "client_delay_access", Config.ClientDelay);
#endif
#if USE_WCCP
    dump_address(entry, "wccp_router", Config.Wccp.router);
#endif
#if USE_WCCPv2
    dump_IpAddress_list(entry, "wccp2_router", Config.Wccp2.router);
#endif
#if USE_WCCP
    dump_int(entry, "wccp_version", Config.Wccp.version);
#endif
#if USE_WCCPv2
    dump_onoff(entry, "wccp2_rebuild_wait", Config.Wccp2.rebuildwait);
#endif
#if USE_WCCPv2
    dump_wccp2_method(entry, "wccp2_forwarding_method", Config.Wccp2.forwarding_method);
#endif
#if USE_WCCPv2
    dump_wccp2_method(entry, "wccp2_return_method", Config.Wccp2.return_method);
#endif
#if USE_WCCPv2
    dump_wccp2_amethod(entry, "wccp2_assignment_method", Config.Wccp2.assignment_method);
#endif
#if USE_WCCPv2
    dump_wccp2_service(entry, "wccp2_service", Config.Wccp2.info);
#endif
#if USE_WCCPv2
    dump_wccp2_service_info(entry, "wccp2_service_info", Config.Wccp2.info);
#endif
#if USE_WCCPv2
    dump_int(entry, "wccp2_weight", Config.Wccp2.weight);
#endif
#if USE_WCCP
    dump_address(entry, "wccp_address", Config.Wccp.address);
#endif
#if USE_WCCPv2
    dump_address(entry, "wccp2_address", Config.Wccp2.address);
#endif
    dump_onoff(entry, "client_persistent_connections", Config.onoff.client_pconns);
    dump_onoff(entry, "server_persistent_connections", Config.onoff.server_pconns);
    dump_onoff(entry, "persistent_connection_after_error", Config.onoff.error_pconns);
    dump_onoff(entry, "detect_broken_pconn", Config.onoff.detect_broken_server_pconns);
#if USE_CACHE_DIGESTS
    dump_onoff(entry, "digest_generation", Config.onoff.digest_generation);
#endif
#if USE_CACHE_DIGESTS
    dump_int(entry, "digest_bits_per_entry", Config.digest.bits_per_entry);
#endif
#if USE_CACHE_DIGESTS
    dump_time_t(entry, "digest_rebuild_period", Config.digest.rebuild_period);
#endif
#if USE_CACHE_DIGESTS
    dump_time_t(entry, "digest_rewrite_period", Config.digest.rewrite_period);
#endif
#if USE_CACHE_DIGESTS
    dump_b_size_t(entry, "digest_swapout_chunk_size", Config.digest.swapout_chunk_size);
#endif
#if USE_CACHE_DIGESTS
    dump_int(entry, "digest_rebuild_chunk_percentage", Config.digest.rebuild_chunk_percentage);
#endif
#if SQUID_SNMP
    dump_u_short(entry, "snmp_port", Config.Port.snmp);
#endif
#if SQUID_SNMP
    dump_acl_access(entry, "snmp_access", Config.accessList.snmp);
#endif
#if SQUID_SNMP
    dump_address(entry, "snmp_incoming_address", Config.Addrs.snmp_incoming);
#endif
#if SQUID_SNMP
    dump_address(entry, "snmp_outgoing_address", Config.Addrs.snmp_outgoing);
#endif
    dump_u_short(entry, "icp_port", Config.Port.icp);
#if USE_HTCP
    dump_u_short(entry, "htcp_port", Config.Port.htcp);
#endif
    dump_onoff(entry, "log_icp_queries", Config.onoff.log_udp);
    dump_address(entry, "udp_incoming_address", Config.Addrs.udp_incoming);
    dump_address(entry, "udp_outgoing_address", Config.Addrs.udp_outgoing);
    dump_onoff(entry, "icp_hit_stale", Config.onoff.icp_hit_stale);
    dump_int(entry, "minimum_direct_hops", Config.minDirectHops);
    dump_int(entry, "minimum_direct_rtt", Config.minDirectRtt);
    dump_int(entry, "netdb_low", Config.Netdb.low);
    dump_int(entry, "netdb_high", Config.Netdb.high);
    dump_time_t(entry, "netdb_ping_period", Config.Netdb.period);
    dump_onoff(entry, "query_icmp", Config.onoff.query_icmp);
    dump_onoff(entry, "test_reachability", Config.onoff.test_reachability);
    dump_int(entry, "icp_query_timeout", Config.Timeout.icp_query);
    dump_int(entry, "maximum_icp_query_timeout", Config.Timeout.icp_query_max);
    dump_int(entry, "minimum_icp_query_timeout", Config.Timeout.icp_query_min);
    dump_time_t(entry, "background_ping_rate", Config.backgroundPingRate);
    dump_wordlist(entry, "mcast_groups", Config.mcast_group_list);
#if MULTICAST_MISS_STREAM
    dump_address(entry, "mcast_miss_addr", Config.mcast_miss.addr);
#endif
#if MULTICAST_MISS_STREAM
    dump_u_short(entry, "mcast_miss_ttl", Config.mcast_miss.ttl);
#endif
#if MULTICAST_MISS_STREAM
    dump_u_short(entry, "mcast_miss_port", Config.mcast_miss.port);
#endif
#if MULTICAST_MISS_STREAM
    dump_string(entry, "mcast_miss_encode_key", Config.mcast_miss.encode_key);
#endif
    dump_int(entry, "mcast_icp_query_timeout", Config.Timeout.mcast_icp_query);
    dump_string(entry, "icon_directory", Config.icons.directory);
    dump_onoff(entry, "global_internal_static", Config.onoff.global_internal_static);
    dump_onoff(entry, "short_icon_urls", Config.icons.use_short_names);
    dump_string(entry, "error_directory", Config.errorDirectory);
#if USE_ERR_LOCALES
    dump_string(entry, "error_default_language", Config.errorDefaultLanguage);
#endif
#if USE_ERR_LOCALES
    dump_onoff(entry, "error_log_languages", Config.errorLogMissingLanguages);
#endif
    dump_string(entry, "err_page_stylesheet", Config.errorStylesheet);
    dump_eol(entry, "err_html_text", Config.errHtmlText);
    dump_onoff(entry, "email_err_data", Config.onoff.emailErrData);
    dump_denyinfo(entry, "deny_info", Config.denyInfoList);
    dump_onoff(entry, "nonhierarchical_direct", Config.onoff.nonhierarchical_direct);
    dump_onoff(entry, "prefer_direct", Config.onoff.prefer_direct);
    dump_acl_access(entry, "always_direct", Config.accessList.AlwaysDirect);
    dump_acl_access(entry, "never_direct", Config.accessList.NeverDirect);
    dump_int(entry, "incoming_udp_average", Config.comm_incoming.udp.average);
    dump_int(entry, "incoming_tcp_average", Config.comm_incoming.tcp.average);
    dump_int(entry, "incoming_dns_average", Config.comm_incoming.dns.average);
    dump_int(entry, "min_udp_poll_cnt", Config.comm_incoming.udp.min_poll);
    dump_int(entry, "min_dns_poll_cnt", Config.comm_incoming.dns.min_poll);
    dump_int(entry, "min_tcp_poll_cnt", Config.comm_incoming.tcp.min_poll);
    dump_string(entry, "accept_filter", Config.accept_filter);
    dump_int(entry, "client_ip_max_connections", Config.client_ip_max_connections);
    dump_b_size_t(entry, "tcp_recv_bufsize", Config.tcpRcvBufsz);
#if ICAP_CLIENT
    dump_onoff(entry, "icap_enable", Adaptation::Icap::TheConfig.onoff);
#endif
#if ICAP_CLIENT
    dump_time_t(entry, "icap_connect_timeout", Adaptation::Icap::TheConfig.connect_timeout_raw);
#endif
#if ICAP_CLIENT
    dump_time_t(entry, "icap_io_timeout", Adaptation::Icap::TheConfig.io_timeout_raw);
#endif
#if ICAP_CLIENT
    dump_icap_service_failure_limit(entry, "icap_service_failure_limit", Adaptation::Icap::TheConfig);
#endif
#if ICAP_CLIENT
    dump_int(entry, "icap_service_revival_delay", Adaptation::Icap::TheConfig.service_revival_delay);
#endif
#if ICAP_CLIENT
    dump_onoff(entry, "icap_preview_enable", Adaptation::Icap::TheConfig.preview_enable);
#endif
#if ICAP_CLIENT
    dump_int(entry, "icap_preview_size", Adaptation::Icap::TheConfig.preview_size);
#endif
#if ICAP_CLIENT
    dump_onoff(entry, "icap_206_enable", Adaptation::Icap::TheConfig.allow206_enable);
#endif
#if ICAP_CLIENT
    dump_int(entry, "icap_default_options_ttl", Adaptation::Icap::TheConfig.default_options_ttl);
#endif
#if ICAP_CLIENT
    dump_onoff(entry, "icap_persistent_connections", Adaptation::Icap::TheConfig.reuse_connections);
#endif
#if USE_ADAPTATION
    dump_onoff(entry, "adaptation_send_client_ip", Adaptation::Config::send_client_ip);
#endif
#if USE_ADAPTATION
    dump_onoff(entry, "adaptation_send_username", Adaptation::Config::send_username);
#endif
#if ICAP_CLIENT
    dump_string(entry, "icap_client_username_header", Adaptation::Icap::TheConfig.client_username_header);
#endif
#if ICAP_CLIENT
    dump_onoff(entry, "icap_client_username_encode", Adaptation::Icap::TheConfig.client_username_encode);
#endif
#if ICAP_CLIENT
    dump_icap_service_type(entry, "icap_service", Adaptation::Icap::TheConfig);
#endif
#if USE_ECAP
    dump_onoff(entry, "ecap_enable", Adaptation::Ecap::TheConfig.onoff);
#endif
#if USE_ECAP
    dump_ecap_service_type(entry, "ecap_service", Adaptation::Ecap::TheConfig);
#endif
#if USE_LOADABLE_MODULES
    dump_wordlist(entry, "loadable_modules", Config.loadable_module_names);
#endif
#if USE_ADAPTATION
    dump_int(entry, "adaptation_service_iteration_limit", Adaptation::Config::service_iteration_limit);
#endif
#if USE_ADAPTATION
    dump_string(entry, "adaptation_masterx_shared_names", Adaptation::Config::masterx_shared_name);
#endif
#if USE_ADAPTATION
    dump_adaptation_meta_type(entry, "adaptation_meta", Adaptation::Config::metaHeaders);
#endif
#if ICAP_CLIENT
    dump_acl_access(entry, "icap_retry", Adaptation::Icap::TheConfig.repeat);
#endif
#if ICAP_CLIENT
    dump_int(entry, "icap_retry_limit", Adaptation::Icap::TheConfig.repeat_limit);
#endif
    dump_onoff(entry, "check_hostnames", Config.onoff.check_hostnames);
    dump_onoff(entry, "allow_underscore", Config.onoff.allow_underscore);
#if USE_DNSHELPER
    dump_string(entry, "cache_dns_program", Config.Program.dnsserver);
#endif
#if USE_DNSHELPER
    dump_HelperChildConfig(entry, "dns_children", Config.dnsChildren);
#endif
#if !USE_DNSHELPER
    dump_time_msec(entry, "dns_retransmit_interval", Config.Timeout.idns_retransmit);
#endif
#if !USE_DNSHELPER
    dump_time_msec(entry, "dns_timeout", Config.Timeout.idns_query);
#endif
#if !USE_DNSHELPER
    dump_b_ssize_t(entry, "dns_packet_max", Config.dns.packet_max);
#endif
    dump_onoff(entry, "dns_defnames", Config.onoff.res_defnames);
    dump_wordlist(entry, "dns_nameservers", Config.dns_nameservers);
    dump_string(entry, "hosts_file", Config.etcHostsPath);
    dump_string(entry, "append_domain", Config.appendDomain);
#if !USE_DNSHELPER
    dump_onoff(entry, "ignore_unknown_nameservers", Config.onoff.ignore_unknown_nameservers);
#endif
#if !USE_DNSHELPER
    dump_onoff(entry, "dns_v4_first", Config.dns.v4_first);
#endif
    dump_int(entry, "ipcache_size", Config.ipcache.size);
    dump_int(entry, "ipcache_low", Config.ipcache.low);
    dump_int(entry, "ipcache_high", Config.ipcache.high);
    dump_int(entry, "fqdncache_size", Config.fqdncache.size);
    dump_onoff(entry, "memory_pools", Config.onoff.mem_pools);
    dump_b_int64_t(entry, "memory_pools_limit", Config.MemPools.limit);
    dump_string(entry, "forwarded_for", opt_forwarded_for);
    dump_cachemgrpasswd(entry, "cachemgr_passwd", Config.passwd_list);
    dump_onoff(entry, "client_db", Config.onoff.client_db);
    dump_onoff(entry, "refresh_all_ims", Config.onoff.refresh_all_ims);
#if USE_HTTP_VIOLATIONS
    dump_onoff(entry, "reload_into_ims", Config.onoff.reload_into_ims);
#endif
    dump_int(entry, "connect_retries", Config.connect_retries);
    dump_onoff(entry, "retry_on_error", Config.retry.onerror);
    dump_string(entry, "as_whois_server", Config.as_whois_server);
    dump_onoff(entry, "offline_mode", Config.onoff.offline);
    dump_uri_whitespace(entry, "uri_whitespace", Config.uri_whitespace);
    dump_string(entry, "chroot", Config.chroot_dir);
    dump_onoff(entry, "balance_on_multiple_ip", Config.onoff.balance_on_multiple_ip);
    dump_onoff(entry, "pipeline_prefetch", Config.onoff.pipeline_prefetch);
    dump_int(entry, "high_response_time_warning", Config.warnings.high_rptm);
    dump_int(entry, "high_page_fault_warning", Config.warnings.high_pf);
    dump_b_size_t(entry, "high_memory_warning", Config.warnings.high_memory);
    dump_int(entry, "sleep_after_fork", Config.sleep_after_fork);
#if _SQUID_MSWIN_
    dump_onoff(entry, "windows_ipaddrchangemonitor", Config.onoff.WIN32_IpAddrChangeMonitor);
#endif
#if USE_SQUID_EUI
    dump_onoff(entry, "eui_lookup", Eui::TheConfig.euiLookup);
#endif
    dump_int(entry, "max_filedescriptors", Config.max_filedescriptors);
    dump_int(entry, "workers", Config.workers);
    dump_CpuAffinityMap(entry, "cpu_affinity_map", Config.cpuAffinityMap);
}

static void
free_all(void)
{
    debugs(5, 4, HERE);
#if USE_AUTH
    free_authparam(&Auth::TheConfig);
#endif
    free_time_t(&Config.authenticateGCInterval);
    free_time_t(&Config.authenticateTTL);
    free_time_t(&Config.authenticateIpTTL);
    free_externalAclHelper(&Config.externalAclHelperList);
    free_acl(&Config.aclList);
#if FOLLOW_X_FORWARDED_FOR
    free_acl_access(&Config.accessList.followXFF);
#endif
#if FOLLOW_X_FORWARDED_FOR
    free_onoff(&Config.onoff.acl_uses_indirect_client);
#endif
#if FOLLOW_X_FORWARDED_FOR&&USE_DELAY_POOLS
    free_onoff(&Config.onoff.delay_pool_uses_indirect_client);
#endif
#if FOLLOW_X_FORWARDED_FOR
    free_onoff(&Config.onoff.log_uses_indirect_client);
#endif
#if FOLLOW_X_FORWARDED_FOR&&LINUX_NETFILTER
    free_onoff(&Config.onoff.tproxy_uses_indirect_client);
#endif
    free_acl_access(&Config.accessList.http);
    free_acl_access(&Config.accessList.adapted_http);
    free_acl_access(&Config.accessList.reply);
    free_acl_access(&Config.accessList.icp);
#if USE_HTCP
    free_acl_access(&Config.accessList.htcp);
#endif
#if USE_HTCP
    free_acl_access(&Config.accessList.htcp_clr);
#endif
    free_acl_access(&Config.accessList.miss);
#if USE_IDENT
    free_acl_access(&Ident::TheConfig.identLookup);
#endif
    free_acl_b_size_t(&Config.ReplyBodySize);
    free_PortCfg(&Config.Sockaddr.http);
#if USE_SSL
    free_PortCfg(&Config.Sockaddr.https);
#endif
    free_acl_tos(&Ip::Qos::TheConfig.tosToServer);
    free_acl_tos(&Ip::Qos::TheConfig.tosToClient);
#if SO_MARK&&USE_LIBCAP
    free_acl_nfmark(&Ip::Qos::TheConfig.nfmarkToServer);
#endif
#if SO_MARK&&USE_LIBCAP
    free_acl_nfmark(&Ip::Qos::TheConfig.nfmarkToClient);
#endif
#if USE_QOS_TOS
    free_QosConfig(&Ip::Qos::TheConfig);
#endif
    free_acl_address(&Config.accessList.outgoing_address);
    free_onoff(&Config.onoff.hostStrictVerify);
    free_onoff(&Config.onoff.client_dst_passthru);
#if USE_SSL
    free_onoff(&Config.SSL.unclean_shutdown);
#endif
#if USE_SSL
    free_string(&Config.SSL.ssl_engine);
#endif
#if USE_SSL
    free_string(&Config.ssl_client.cert);
#endif
#if USE_SSL
    free_string(&Config.ssl_client.key);
#endif
#if USE_SSL
    free_int(&Config.ssl_client.version);
#endif
#if USE_SSL
    free_string(&Config.ssl_client.options);
#endif
#if USE_SSL
    free_string(&Config.ssl_client.cipher);
#endif
#if USE_SSL
    free_string(&Config.ssl_client.cafile);
#endif
#if USE_SSL
    free_string(&Config.ssl_client.capath);
#endif
#if USE_SSL
    free_sslproxy_ssl_bump(&Config.accessList.ssl_bump);
#endif
#if USE_SSL
    free_string(&Config.ssl_client.flags);
#endif
#if USE_SSL
    free_acl_access(&Config.ssl_client.cert_error);
#endif
#if USE_SSL
    free_sslproxy_cert_sign(&Config.ssl_client.cert_sign);
#endif
#if USE_SSL
    free_sslproxy_cert_adapt(&Config.ssl_client.cert_adapt);
#endif
#if USE_SSL
    free_string(&Config.Program.ssl_password);
#endif
#if USE_SSL_CRTD
    free_eol(&Ssl::TheConfig.ssl_crtd);
#endif
#if USE_SSL_CRTD
    free_HelperChildConfig(&Ssl::TheConfig.ssl_crtdChildren);
#endif
    free_peer(&Config.peers);
    free_time_t(&Config.Timeout.deadPeer);
    free_int(&Config.forward_max_tries);
    free_wordlist(&Config.hierarchy_stoplist);
    free_b_size_t(&Config.memMaxSize);
    free_b_size_t(&Config.Store.maxInMemObjSize);
    free_YesNoNone(&Config.memShared);
    free_memcachemode(&Config);
    free_removalpolicy(&Config.memPolicy);
    free_removalpolicy(&Config.replPolicy);
    free_cachedir(&Config.cacheSwap);
    free_string(&Config.store_dir_select_algorithm);
    free_int(&Config.max_open_disk_fds);
    free_b_int64_t(&Config.Store.minObjectSize);
    free_b_int64_t(&Config.Store.maxObjectSize);
    free_int(&Config.Swap.lowWaterMark);
    free_int(&Config.Swap.highWaterMark);
    free_logformat(&Log::TheConfig);
    free_access_log(&Config.Log.accesslogs);
#if ICAP_CLIENT
    free_access_log(&Config.Log.icaplogs);
#endif
    free_string(&Log::TheConfig.logfile_daemon);
    free_acl_access(&Config.accessList.log);
#if ICAP_CLIENT
    free_acl_access(&Config.accessList.icap);
#endif
    free_string(&Config.Log.store);
    free_string(&Config.Log.swap);
    free_int(&Config.Log.rotateNumber);
    free_string(&Config.mimeTablePathname);
    free_onoff(&Config.onoff.log_mime_hdrs);
    free_string(&Config.pidFilename);
    free_address(&Config.Addrs.client_netmask);
    free_onoff(&Config.onoff.strip_query_terms);
    free_onoff(&Config.onoff.buffered_logs);
#if USE_ICMP
    free_string(&Config.netdbFilename);
#endif
    free_string(&Debug::cache_log);
    free_eol(&Debug::debugOptions);
    free_string(&Config.coredump_dir);
    free_string(&Config.Ftp.anon_user);
    free_onoff(&Config.Ftp.passive);
    free_onoff(&Config.Ftp.epsv_all);
    free_onoff(&Config.Ftp.epsv);
    free_onoff(&Config.Ftp.eprt);
    free_onoff(&Config.Ftp.sanitycheck);
    free_onoff(&Config.Ftp.telnet);
    free_string(&Config.Program.diskd);
#if USE_UNLINKD
    free_string(&Config.Program.unlinkd);
#endif
#if USE_ICMP
    free_string(&Config.pinger.program);
#endif
#if USE_ICMP
    free_onoff(&Config.pinger.enable);
#endif
    free_wordlist(&Config.Program.redirect);
    free_HelperChildConfig(&Config.redirectChildren);
    free_onoff(&Config.onoff.redir_rewrites_host);
    free_acl_access(&Config.accessList.redirector);
    free_onoff(&Config.onoff.redirector_bypass);
    free_acl_access(&Config.accessList.noCache);
    free_time_t(&Config.maxStale);
    free_refreshpattern(&Config.Refresh);
    free_kb_int64_t(&Config.quickAbort.min);
    free_kb_int64_t(&Config.quickAbort.max);
    free_int(&Config.quickAbort.pct);
    free_b_int64_t(&Config.readAheadGap);
#if USE_HTTP_VIOLATIONS
    free_time_t(&Config.negativeTtl);
#endif
    free_time_t(&Config.positiveDnsTtl);
    free_time_t(&Config.negativeDnsTtl);
    free_acl_b_size_t(&Config.rangeOffsetLimit);
    free_time_t(&Config.minimum_expiry_time);
    free_b_int64_t(&Config.Store.avgObjectSize);
    free_int(&Config.Store.objectsPerBucket);
    free_b_size_t(&Config.maxRequestHeaderSize);
    free_b_size_t(&Config.maxReplyHeaderSize);
    free_b_int64_t(&Config.maxRequestBodySize);
    free_b_size_t(&Config.maxRequestBufferSize);
    free_b_int64_t(&Config.maxChunkedRequestBodySize);
#if USE_HTTP_VIOLATIONS
    free_acl_access(&Config.accessList.brokenPosts);
#endif
#if FOLLOW_X_FORWARDED_FOR&&USE_ADAPTATION
    free_onoff(&Adaptation::Config::use_indirect_client);
#endif
#if USE_HTTP_VIOLATIONS
    free_onoff(&Config.onoff.via);
#endif
    free_onoff(&Config.onoff.ie_refresh);
    free_onoff(&Config.onoff.vary_ignore_expire);
    free_onoff(&Config.onoff.request_entities);
#if USE_HTTP_VIOLATIONS
    free_http_header_access(&Config.request_header_access);
#endif
#if USE_HTTP_VIOLATIONS
    free_http_header_access(&Config.reply_header_access);
#endif
#if USE_HTTP_VIOLATIONS
    free_http_header_replace(&Config.request_header_access);
#endif
#if USE_HTTP_VIOLATIONS
    free_http_header_replace(&Config.reply_header_access);
#endif
    free_HeaderWithAclList(&Config.request_header_add);
    free_tristate(&Config.onoff.relaxed_header_parser);
    free_time_t(&Config.Timeout.forward);
    free_time_t(&Config.Timeout.connect);
    free_time_t(&Config.Timeout.peer_connect);
    free_time_t(&Config.Timeout.read);
    free_time_t(&Config.Timeout.write);
    free_time_t(&Config.Timeout.request);
    free_time_t(&Config.Timeout.clientIdlePconn);
    free_time_t(&Config.Timeout.lifetime);
    free_onoff(&Config.onoff.half_closed_clients);
    free_time_t(&Config.Timeout.serverIdlePconn);
#if USE_IDENT
    free_time_t(&Ident::TheConfig.timeout);
#endif
    free_time_t(&Config.shutdownLifetime);
    free_string(&Config.adminEmail);
    free_string(&Config.EmailFrom);
    free_eol(&Config.EmailProgram);
    free_string(&Config.effectiveUser);
    free_string(&Config.effectiveGroup);
    free_onoff(&Config.onoff.httpd_suppress_version_string);
    free_string(&Config.visibleHostname);
    free_string(&Config.uniqueHostname);
    free_wordlist(&Config.hostnameAliases);
    free_int(&Config.umask);
    free_time_t(&Config.Announce.period);
    free_string(&Config.Announce.host);
    free_string(&Config.Announce.file);
    free_u_short(&Config.Announce.port);
    free_string(&Config.Accel.surrogate_id);
    free_onoff(&Config.onoff.surrogate_is_remote);
#if USE_SQUID_ESI
    free_string(&ESIParser::Type);
#endif
#if USE_DELAY_POOLS
    free_delay_pool_count(&Config.Delay);
#endif
#if USE_DELAY_POOLS
    free_delay_pool_class(&Config.Delay);
#endif
#if USE_DELAY_POOLS
    free_delay_pool_access(&Config.Delay);
#endif
#if USE_DELAY_POOLS
    free_delay_pool_rates(&Config.Delay);
#endif
#if USE_DELAY_POOLS
    free_u_short(&Config.Delay.initial);
#endif
#if USE_DELAY_POOLS
    free_client_delay_pool_count(&Config.ClientDelay);
#endif
#if USE_DELAY_POOLS
    free_u_short(&Config.ClientDelay.initial);
#endif
#if USE_DELAY_POOLS
    free_client_delay_pool_rates(&Config.ClientDelay);
#endif
#if USE_DELAY_POOLS
    free_client_delay_pool_access(&Config.ClientDelay);
#endif
#if USE_WCCP
    free_address(&Config.Wccp.router);
#endif
#if USE_WCCPv2
    free_IpAddress_list(&Config.Wccp2.router);
#endif
#if USE_WCCP
    free_int(&Config.Wccp.version);
#endif
#if USE_WCCPv2
    free_onoff(&Config.Wccp2.rebuildwait);
#endif
#if USE_WCCPv2
    free_wccp2_method(&Config.Wccp2.forwarding_method);
#endif
#if USE_WCCPv2
    free_wccp2_method(&Config.Wccp2.return_method);
#endif
#if USE_WCCPv2
    free_wccp2_amethod(&Config.Wccp2.assignment_method);
#endif
#if USE_WCCPv2
    free_wccp2_service(&Config.Wccp2.info);
#endif
#if USE_WCCPv2
    free_wccp2_service_info(&Config.Wccp2.info);
#endif
#if USE_WCCPv2
    free_int(&Config.Wccp2.weight);
#endif
#if USE_WCCP
    free_address(&Config.Wccp.address);
#endif
#if USE_WCCPv2
    free_address(&Config.Wccp2.address);
#endif
    free_onoff(&Config.onoff.client_pconns);
    free_onoff(&Config.onoff.server_pconns);
    free_onoff(&Config.onoff.error_pconns);
    free_onoff(&Config.onoff.detect_broken_server_pconns);
#if USE_CACHE_DIGESTS
    free_onoff(&Config.onoff.digest_generation);
#endif
#if USE_CACHE_DIGESTS
    free_int(&Config.digest.bits_per_entry);
#endif
#if USE_CACHE_DIGESTS
    free_time_t(&Config.digest.rebuild_period);
#endif
#if USE_CACHE_DIGESTS
    free_time_t(&Config.digest.rewrite_period);
#endif
#if USE_CACHE_DIGESTS
    free_b_size_t(&Config.digest.swapout_chunk_size);
#endif
#if USE_CACHE_DIGESTS
    free_int(&Config.digest.rebuild_chunk_percentage);
#endif
#if SQUID_SNMP
    free_u_short(&Config.Port.snmp);
#endif
#if SQUID_SNMP
    free_acl_access(&Config.accessList.snmp);
#endif
#if SQUID_SNMP
    free_address(&Config.Addrs.snmp_incoming);
#endif
#if SQUID_SNMP
    free_address(&Config.Addrs.snmp_outgoing);
#endif
    free_u_short(&Config.Port.icp);
#if USE_HTCP
    free_u_short(&Config.Port.htcp);
#endif
    free_onoff(&Config.onoff.log_udp);
    free_address(&Config.Addrs.udp_incoming);
    free_address(&Config.Addrs.udp_outgoing);
    free_onoff(&Config.onoff.icp_hit_stale);
    free_int(&Config.minDirectHops);
    free_int(&Config.minDirectRtt);
    free_int(&Config.Netdb.low);
    free_int(&Config.Netdb.high);
    free_time_t(&Config.Netdb.period);
    free_onoff(&Config.onoff.query_icmp);
    free_onoff(&Config.onoff.test_reachability);
    free_int(&Config.Timeout.icp_query);
    free_int(&Config.Timeout.icp_query_max);
    free_int(&Config.Timeout.icp_query_min);
    free_time_t(&Config.backgroundPingRate);
    free_wordlist(&Config.mcast_group_list);
#if MULTICAST_MISS_STREAM
    free_address(&Config.mcast_miss.addr);
#endif
#if MULTICAST_MISS_STREAM
    free_u_short(&Config.mcast_miss.ttl);
#endif
#if MULTICAST_MISS_STREAM
    free_u_short(&Config.mcast_miss.port);
#endif
#if MULTICAST_MISS_STREAM
    free_string(&Config.mcast_miss.encode_key);
#endif
    free_int(&Config.Timeout.mcast_icp_query);
    free_string(&Config.icons.directory);
    free_onoff(&Config.onoff.global_internal_static);
    free_onoff(&Config.icons.use_short_names);
    free_string(&Config.errorDirectory);
#if USE_ERR_LOCALES
    free_string(&Config.errorDefaultLanguage);
#endif
#if USE_ERR_LOCALES
    free_onoff(&Config.errorLogMissingLanguages);
#endif
    free_string(&Config.errorStylesheet);
    free_eol(&Config.errHtmlText);
    free_onoff(&Config.onoff.emailErrData);
    free_denyinfo(&Config.denyInfoList);
    free_onoff(&Config.onoff.nonhierarchical_direct);
    free_onoff(&Config.onoff.prefer_direct);
    free_acl_access(&Config.accessList.AlwaysDirect);
    free_acl_access(&Config.accessList.NeverDirect);
    free_int(&Config.comm_incoming.udp.average);
    free_int(&Config.comm_incoming.tcp.average);
    free_int(&Config.comm_incoming.dns.average);
    free_int(&Config.comm_incoming.udp.min_poll);
    free_int(&Config.comm_incoming.dns.min_poll);
    free_int(&Config.comm_incoming.tcp.min_poll);
    free_string(&Config.accept_filter);
    free_int(&Config.client_ip_max_connections);
    free_b_size_t(&Config.tcpRcvBufsz);
#if ICAP_CLIENT
    free_onoff(&Adaptation::Icap::TheConfig.onoff);
#endif
#if ICAP_CLIENT
    free_time_t(&Adaptation::Icap::TheConfig.connect_timeout_raw);
#endif
#if ICAP_CLIENT
    free_time_t(&Adaptation::Icap::TheConfig.io_timeout_raw);
#endif
#if ICAP_CLIENT
    free_icap_service_failure_limit(&Adaptation::Icap::TheConfig);
#endif
#if ICAP_CLIENT
    free_int(&Adaptation::Icap::TheConfig.service_revival_delay);
#endif
#if ICAP_CLIENT
    free_onoff(&Adaptation::Icap::TheConfig.preview_enable);
#endif
#if ICAP_CLIENT
    free_int(&Adaptation::Icap::TheConfig.preview_size);
#endif
#if ICAP_CLIENT
    free_onoff(&Adaptation::Icap::TheConfig.allow206_enable);
#endif
#if ICAP_CLIENT
    free_int(&Adaptation::Icap::TheConfig.default_options_ttl);
#endif
#if ICAP_CLIENT
    free_onoff(&Adaptation::Icap::TheConfig.reuse_connections);
#endif
#if USE_ADAPTATION
    free_onoff(&Adaptation::Config::send_client_ip);
#endif
#if USE_ADAPTATION
    free_onoff(&Adaptation::Config::send_username);
#endif
#if ICAP_CLIENT
    free_string(&Adaptation::Icap::TheConfig.client_username_header);
#endif
#if ICAP_CLIENT
    free_onoff(&Adaptation::Icap::TheConfig.client_username_encode);
#endif
#if ICAP_CLIENT
    free_icap_service_type(&Adaptation::Icap::TheConfig);
#endif
#if USE_ECAP
    free_onoff(&Adaptation::Ecap::TheConfig.onoff);
#endif
#if USE_ECAP
    free_ecap_service_type(&Adaptation::Ecap::TheConfig);
#endif
#if USE_LOADABLE_MODULES
    free_wordlist(&Config.loadable_module_names);
#endif
#if USE_ADAPTATION
    free_int(&Adaptation::Config::service_iteration_limit);
#endif
#if USE_ADAPTATION
    free_string(&Adaptation::Config::masterx_shared_name);
#endif
#if USE_ADAPTATION
    free_adaptation_meta_type(&Adaptation::Config::metaHeaders);
#endif
#if ICAP_CLIENT
    free_acl_access(&Adaptation::Icap::TheConfig.repeat);
#endif
#if ICAP_CLIENT
    free_int(&Adaptation::Icap::TheConfig.repeat_limit);
#endif
    free_onoff(&Config.onoff.check_hostnames);
    free_onoff(&Config.onoff.allow_underscore);
#if USE_DNSHELPER
    free_string(&Config.Program.dnsserver);
#endif
#if USE_DNSHELPER
    free_HelperChildConfig(&Config.dnsChildren);
#endif
#if !USE_DNSHELPER
    free_time_msec(&Config.Timeout.idns_retransmit);
#endif
#if !USE_DNSHELPER
    free_time_msec(&Config.Timeout.idns_query);
#endif
#if !USE_DNSHELPER
    free_b_ssize_t(&Config.dns.packet_max);
#endif
    free_onoff(&Config.onoff.res_defnames);
    free_wordlist(&Config.dns_nameservers);
    free_string(&Config.etcHostsPath);
    free_string(&Config.appendDomain);
#if !USE_DNSHELPER
    free_onoff(&Config.onoff.ignore_unknown_nameservers);
#endif
#if !USE_DNSHELPER
    free_onoff(&Config.dns.v4_first);
#endif
    free_int(&Config.ipcache.size);
    free_int(&Config.ipcache.low);
    free_int(&Config.ipcache.high);
    free_int(&Config.fqdncache.size);
    free_onoff(&Config.onoff.mem_pools);
    free_b_int64_t(&Config.MemPools.limit);
    free_string(&opt_forwarded_for);
    free_cachemgrpasswd(&Config.passwd_list);
    free_onoff(&Config.onoff.client_db);
    free_onoff(&Config.onoff.refresh_all_ims);
#if USE_HTTP_VIOLATIONS
    free_onoff(&Config.onoff.reload_into_ims);
#endif
    free_int(&Config.connect_retries);
    free_onoff(&Config.retry.onerror);
    free_string(&Config.as_whois_server);
    free_onoff(&Config.onoff.offline);
    free_uri_whitespace(&Config.uri_whitespace);
    free_string(&Config.chroot_dir);
    free_onoff(&Config.onoff.balance_on_multiple_ip);
    free_onoff(&Config.onoff.pipeline_prefetch);
    free_int(&Config.warnings.high_rptm);
    free_int(&Config.warnings.high_pf);
    free_b_size_t(&Config.warnings.high_memory);
    free_int(&Config.sleep_after_fork);
#if _SQUID_MSWIN_
    free_onoff(&Config.onoff.WIN32_IpAddrChangeMonitor);
#endif
#if USE_SQUID_EUI
    free_onoff(&Eui::TheConfig.euiLookup);
#endif
    free_int(&Config.max_filedescriptors);
    free_int(&Config.workers);
    free_CpuAffinityMap(&Config.cpuAffinityMap);
}

